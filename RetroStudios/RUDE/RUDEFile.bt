//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: RetroStudiosFile.bt
//   Authors: LolHacksRule
//   Version: 
//   Purpose: Reading packed and unpacked files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../LHR/Common.bt"
#include "RUDECommon.bt"
//#include "Prime1Remaster.bt
//#include "GameSpecific/DKCTF.bt"

//Original sources
//http://www.metroid2002.com/retromodding/wiki
//https://github.com/kinnay/Nintendo-File-Formats/wiki
//This was ported to aid with studying those 3d games from Retro's RUDE Engine. Only tested on DKCTF and Retail Demo! The MP1 remaster also uses this engine but I haven't tested it

local string MessageTableBinDir = "Interface/messages/";
local string GFXDir = "Interface/swfs/";
local string LooseDataTweaksDir = "LooseDataTweaks/Controls/";
local string AudioDir = "audio/";
local string WorldDir = "Worlds/"; //World files probably reside in Worlds/pakname, ie b00_mangrove_seaLion.rsd from Worlds/w01/b00_mangrove_seaLion.pak would reside in Worlds/w01_mangrove, the only one we do know is Worlds/UI/FrontEndLevel.rsd in UI.pak

local uint i3<hidden=true> = 0;
//local uint totalLayerCount<hidden=true> = 0;
//local uint i2<hidden=true> = 0;
local uint terminateUINF<hidden=true> = 0;
local uint terminateGameObjDetection<hidden=true> = 0;
local uint terminateLoadUnitDetection<hidden=true> = 0;
local uint addExtension<hidden=true> = 0;
local uint isSDX<hidden=true> = 0;
local uint isDSubComp<hidden=true> = 0;
local uint isGameObjectComponent<hidden=true> = 0;
//local uint hasTXTRMeta <hidden=true> = 0;
//local uint disableStructFields<hidden=true> = 0;
local uint checkLocalMETA <hidden=true> = 0;
local uint DependencyGroups <hidden=true> = 0;
local uint tree_forDCLN <hidden=true> = 0;
local uint isCLSN <hidden=true> = 0; //Use this to force Material chunks for CLSNs
local uint isLegacyCLSN <hidden=true> = 0; //A fix for detecting V2 clsn
local uint isPack <hidden=true> = 0; //A fix for detecting pack and not reusing forms
local uint isWMDL <hidden=true> = 0;
local uint isSMDL <hidden=true> = 0;
local uint isNX <hidden=true> = 0; //Check for NX, NX uses Int32 strings instead of static strings and also newer audio samples and message tables

struct RUDEFile
{
    BigEndian(); 
    //Well Retro finally made NX builds use LE which messes this up
    FormDescriptor ContentForm;
    if (ContentForm.hdr == Export) //Read individual uncompressed shader file (WIP!)
    {
        FSkip(-32);
        MaterialChunk theExport;
        break;
    }
    if (ContentForm.contentType == Package)
    {
        isPack = 1;
        PackageChunk ThePackageContent;
    }
    if (ContentForm.contentType == Material)
    {
        MaterialChunk TheMaterialChunk;
        if (isSDX == 1)
        {
            checkLocalMETA = 0;
        }
    }
    if (ContentForm.contentType == RFLO)
    {
        RenderFlowChunk RFLOContent;
    }
    if (ContentForm.contentType == MessageTable_MessageStudioBinaryText)
    {
        MessageTableChunk MessageTableContent;
    }
    if (ContentForm.contentType == CookedAudioSample)
    {
        CookedAudioSampleChunk CookedAudioSampleContent;
        if (ContentForm.fVer == 18 && ContentForm.dVer == 18) //Detect NX audio
        {
            checkLocalMETA = 1;
        }
    }
    if (ContentForm.contentType == CookedAudioSoundEffect)
    {
        CookedAudioSoundEffectChunk CookedAudioSoundEffectContent;
    }
    if (ContentForm.contentType == CookedAudioBusHeiarchy)
    {
        CookedAudioBusHeirachyChunk CookedAudioBusHeirachyContent;
    }
    if (ContentForm.contentType == Texture)
    {
        TextureChunk TextureContent;
        if (isNX)
        {
            checkLocalMETA = 1;
        }
    }
    if (ContentForm.contentType == CookedModel || ContentForm.contentType == SkinnedModel || ContentForm.contentType == WorldModel)
    {
        if (ContentForm.contentType == WorldModel)
        {
            isWMDL = 1;
        }
        if (ContentForm.contentType == SkinnedModel)
        {
            isSMDL = 1;
        }
        ModelChunk ModelContent;
        checkLocalMETA = 1;
    }
    if (ContentForm.contentType == GenericParticleSystem)
    {
        GenericParticleSystemChunk GenericParticleSystemContent;
        //checkLocalMETA = 1;
    }
    if (ContentForm.contentType == DependencyGroup)
    {
        DependencyGroupChunk DependencyGroupContent;
    }
    if (ContentForm.contentType == Animation)
    {
        AnimationChunk AnimationContent;
    }
    if (ContentForm.contentType == ExtendedTransformAnimation)
    {
        AnimationTransformChunk AnimationTransformContent;
    }
    if (ContentForm.contentType == Skeleton)
    {
        SkeletonChunk SkeletonContent;
    }
    if (ContentForm.contentType == Character)
    {
        CharacterChunk CharacterContent;
    }
    if (ContentForm.contentType == UniverseInfo)
    {
        UniverseInfoChunk UniverseInfoContent;
    }
    if (ContentForm.contentType == FiniteStateMachine)
    {
        FiniteStateMachineChunk FiniteStateMachineContent;
    }
    if (ContentForm.contentType == FlashGFX)
    {
        FlashGFXChunk FlashGFXContent;
    }
    if (ContentForm.contentType == ScaleformGFXLibrary)
    {
        ScaleformGFXLibraryChunk ScaleformGFXLibraryContent;
    }
    if (ContentForm.contentType == Collision)
    {
        isCLSN = 1;
        CollisionChunk CollisionContent;
    }
    if (ContentForm.contentType == SwooshParticleSystem)
    {
        SwooshParticleSystemChunk SwooshParticleSystemContent;
        checkLocalMETA = 1;
    }
    if (ContentForm.contentType == Room)
    {
        RoomChunk RoomContent;
    }
    if (ContentForm.contentType == LooseData)
    {
        LooseDataChunk LooseDataContent;
    }
    if (ContentForm.contentType == RuleSetConfig)
    {
        RuleSetConfigChunk RuleSetConfigContent;
    }
    if (ContentForm.contentType == DynamicCollision)
    {
        isCLSN = 1;
        if (ContentForm.dVer <= 2)
        {
            isLegacyCLSN = 1;
        }
        DynamicCollisionChunk DynamicCollisionContent;
    }
    if (checkLocalMETA == 1)
    {
        MetaDataChunk theMeta;
    }
} RUDEFileData;