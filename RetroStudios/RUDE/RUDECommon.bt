//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//Format info

typedef enum <uint32>
{
    AreaOctree = 1464092740,
    Font = 1414418246,
    LooseData = 1279546433,
    LooseDataContentHeader = 1279542088,
    TableOfContentsContent = 1414480707,
    MessageTable_MessageStudioBinaryText = 1297302100,
    RUDEFormDescriptor = 1380340301,
    CookedAudioSample = 1129532752,
    CookedAudioSoundEffect = 1128355140,
    AssetDirectory = 1094994258,
    CookedAudioBusHeiarchy = 1128350280,
    DependencyGroup = 1145524816,
    Package = 1346454347,
    UniverseInfo = 1430867526,
    Collision = 1129075534,
    DynamicCollision = 1145261134,
    Material = 1297371724,
    ShaderX  = 1396987936,
    ShaderGX2  = 1397184562,
    ShaderNVN  = 1314278995,
    Strings = 1398035015,
    RFLO = 1380338767,
    Mesh = 1296388936,
    InformationBlock = 1229866575,
    Vertices = 1447383636,
    Triangles = 1414678867,
    Metadata = 1296389185,
    Texture = 1415074898,
    GenericHeader = 1212498244,
    TreeNode = 1414677829,
    Room = 1380929357,
    RoomHeader = 1380796484,
    Export = 1163415636,
    CookedModel = 1129137228,
    WorldModel = 1464681548,
    SkinnedModel = 1397572684,
    GenericParticleSystem = 1195724368,
    Description = 1145393987,
    Animation = 1095649613,
    ExtendedTransformAnimation = 1481003597,
    Skeleton = 1397441868,
    Character = 1128808786,
    FlashGFX = 1195792416, //DKCTF
    ScaleformGFXLibrary = 1195792460, //DKCTF
    FiniteStateMachine = 1179864387,
    AudioLabel = 1279345228,
    AudioFormatAlloc = 1179472961,
    DSPAudioData = 1145132097,
    GPUCompressed = 1196447008,
    SwooshParticleSystem = 1398231880,
    RuleSetConfig = 1381192771,
    RuleChunk = 1381321797,
    LightProbe = 1280332354,
    LayerHeader = 1279804740,
    LayerChunk = 1279351122,
    GeneratedScriptObject = 1196642896,
    ScriptObject = 1397901648,
    ComponentChunk = 1129270608,
    GeneratedGameObjectChunk = 1195855682,
    PerformanceGroupChunk = 1346851408,
    LevelGeneratedChunk = 1279739214,
    LoadUnitChunk = 1280659028,
    LoadUnitHeader = 1280657476,
    LoadUnitResourcesChunk = 1280460115,
    LoadUnitLayerChunk = 1280072018,
    //Translations (not sure if they are also for Prime 1 remaster
    US_English = 1431520590,
    US_French = 1431520850,
    US_Spanish = 1431524176,
    EU_English = 1163216206,
    EU_French = 1163216466,
    EU_Spanish = 1163219792,
    EU_German = 1163216709,
    EU_Italian = 1163217236,
    JA_Japanese = 1246775888,
    //Prime1Remaster!
    /*Prime1R_Enumerator,
    Prime1R_SHNT,
    Prime1R_CHPR, //Character Param?
    Prime1R_ELC2, //Electric gen 2?
    Prime1R_LFSM, //Some script macro
    Prime1R_MATI, //Material Info?
    Prime1R_CMAP,
    Prime1R_GUIF, //GUI Font/File?
    Prime1R_LMPU,
    Prime1R_LUHR, //Load Unit Heap Room?
    Prime1R_VECF, //Vector Float has to be, what else starts with VEC
    Prime1R_LSCN, //Level Scene?
    Prime1R_LTPB, //Light Probe?
    Prime1R_MCON,
    Prime1R_LPTH, //Level path?
    Prime1R_SVGM, //SaveGame?
    Prime1R_CBNK, //CookedSoundBank?
    Prime1R_CMID,
    Prime1R_FMV0, //Full Motion Video?
    */
    //Prime!
    Prime_CollisionResponseMacro = 1297306179,
    Prime_DecalParamScriptMacro = 1297305668,
    //Prime_ElectricScriptMacro, //Electric gen 2?
    //Prime_WeaponScriptMacro,
} DataType;

typedef enum <uint32>
{
    Phong = 1346915911,
} MaterialType;

//DKCTF Enums

typedef enum <byte>{
    StandardLevel,
    Boss,
    KONGBonusLevel
} DKCTF_LevelType;

typedef enum <uint32>{
    GX2_SURFACE_DIM_TEXTURE_1D,
    GX2_SURFACE_DIM_TEXTURE_2D,
    GX2_SURFACE_DIM_TEXTURE_3D,
    GX2_SURFACE_DIM_TEXTURE_CUBE,
    GX2_SURFACE_DIM_TEXTURE_1D_ARRAY,
    GX2_SURFACE_DIM_TEXTURE_2D_ARRAY,
    GX2_SURFACE_DIM_TEXTURE_2D_MSAA,
    GX2_SURFACE_DIM_TEXTURE_2D_MSAA_ARRAY
} TexType;

typedef enum <uint32>{
    GX2_SURFACE_FORMAT_UNORM_R8,
    GX2_SURFACE_FORMAT_SNORM_R8,
    GX2_SURFACE_FORMAT_UINT_R8,
    GX2_SURFACE_FORMAT_SINT_R8,
    GX2_SURFACE_FORMAT_UNORM_R16,
    GX2_SURFACE_FORMAT_SNORM_R16,
    GX2_SURFACE_FORMAT_UINT_R16,
    GX2_SURFACE_FORMAT_SINT_R16,
    GX2_SURFACE_FORMAT_FLOAT_R16,
    GX2_SURFACE_FORMAT_UINT_R32,
    GX2_SURFACE_FORMAT_SINT_R32,
    GX2_SURFACE_FORMAT_INVALID,
    GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8,
    GX2_SURFACE_FORMAT_SRGB_R8_G8_B8_A8,
    GX2_SURFACE_FORMAT_FLOAT_R16_G16_B16_A16,
    GX2_SURFACE_FORMAT_FLOAT_R32_G32_B32_A32,
    GX2_SURFACE_FORMAT_UNORM_R16_2,
    GX2_SURFACE_FORMAT_UNORM_R16_3,
    GX2_SURFACE_FORMAT_UNORM_R24_X8,
    GX2_SURFACE_FORMAT_FLOAT_R32,
    GX2_SURFACE_FORMAT_UNORM_BC1,
    GX2_SURFACE_FORMAT_SRGB_BC1,
    GX2_SURFACE_FORMAT_UNORM_BC2,
    GX2_SURFACE_FORMAT_SRGB_BC2,
    GX2_SURFACE_FORMAT_UNORM_BC3,
    GX2_SURFACE_FORMAT_SRGB_BC3,
    GX2_SURFACE_FORMAT_UNORM_BC4,
    GX2_SURFACE_FORMAT_SNORM_BC4,
    GX2_SURFACE_FORMAT_UNORM_BC5,
    GX2_SURFACE_FORMAT_SNORM_BC5,
    GX2_SURFACE_FORMAT_FLOAT_R11_G11_B10,
    GX2_SURFACE_FORMAT_FLOAT_R32_2,
    GX2_SURFACE_FORMAT_FLOAT_R16_G16,
    GX2_SURFACE_FORMAT_UNORM_R8_G8,
    NX_ASTC_2D_12X10 = 54,
    NX_ASTC_2D_6X5,
    NX_ASTC_2D_UNKNOWN = 58
} TexFmt;

typedef enum <uint32>{
    SLdrPlayerMovementControls = 0x0BB87142,
    SLdrPlayerMovementControls_field_0 = 0xE721B25B,
    SLdrMapControls = 0x8BF97C46,
    SLdrMiscControls = 0xC7357581,
    SLdrDebugControls = 0x7742A311,
    SLdrCommandControls_enum_100071d8 = 0xD972289E,
    UNKNOWN_LOOSE_DATA_TEST_1 = 0xC72CC138,
    UNKNOWN_LOOSE_DATA_TEST_2 = 0x64429B5B,
    //Components
    CEntityGOC = 0x749749F1,
	CFakePlayerControlsGOC = 0x4EC5FA3A,
	CStaticCollisionGOC = 0x57153AA4,
	CRenderWorldGOC = 0x41956904,
	CActorCollisionGOC = 0xB4361E7B,
	CLightStaticGOC = 0x2BE8BC19,
	CLightDynamicGOC = 0x9EE5541D,
	CEffectGOC = 0xCD098F70,
	CRelayGOC = 0x8FE0BFC9,
	CCounterGOC = 0xA7DB53C1,
	CSeaLionGOC = 0xADA85938,
	CWarusKingGOC = 0xAAEBA313,
	CSwitchGOC = 0x05DD288E,
	CTimerGOC = 0x9E8A4940,
	CControllerActionGOC = 0xD616EE8B,
	CWaypointGOC = 0xD898656D,
	CPathControlGOC = 0xF0240D23,
	CCameraHintGOC = 0x4FE57689,
	CTouchableTriggerGOC = 0x97E65DDD,
	CToucherGOC = 0x1A4117AB,
	CTriggerLogicGOC = 0xC49D730E,
	CFiniteStateMachineGOC = 0xD47974E4,
	CCustomInterpolationGOC = 0x1349E5AC,
	CCameraTargetGOC = 0xC1F64515,
	CGeneratorGOC = 0xDE522669,
	CGeneratorDeleterGOC = 0x1383F6D6,
	CSplineMotionGOC = 0x2C4F2D31,
	CCreatureGOC = 0x1223437C,
	CDynamicActorCollisionGOC = 0x21C57D2B,
	CRenderGOC = 0xDF31EC16,
	CPlayerGOC = 0xAE921C3B,
	CDirectionalIrradianceMapGOC = 0x81A242A0,
	CTakeDamageGOC = 0xBDE4AB05,
	CMasterSlaveGOC = 0x5453C979,
	CTraceObjectGOC = 0x07E3137F,
	CTimerSequenceGOC = 0x046FAD23,
	CApplyDamageGOC = 0x3175DF36,
	CRelayRandomGOC = 0x65E2349B,
	CRelayConditionalGOC = 0xABBCFC6A,
	CSpawnPointGOC = 0xEA30E0B1,
	CActorKeyframeGOC = 0x1FB9AF22,
	CPlayerProxyGOC = 0xCB6D9ACE,
	CBarrelCannonGOC = 0x6FB22081,
	CRumbleEffectGOC = 0xF4567AD7,
	CObjectFollowGOC = 0x10EA9EC8,
	CPickupGOC = 0x481EA5AF,
	CCameraManagerGOC = 0xBC9A60AE,
	CGroundPoundDetectorGOC = 0xDB38B3FB,
	CProjectileGOC = 0xBE82DEF3,
	CClingPathControlGOC = 0x43C0D52A,
	CColorModifierGOC = 0xB85D6790,
	CExplosionGOC = 0x021C14B0,
	CReloadSetLoaderGOC = 0x16702F15,
	CCheckpointGOC = 0x660FC7C1,
	CPlayerRespawnGOC = 0x8C2CCFAC,
	CImpulseDriverGOC = 0xC0281AE7,
	CBouncerGOC = 0xD4538C9B,
	CHealthGOC = 0x06E89BE7,
	CPlayerActionHintGOC = 0xE0AFAF06,
	CGrabbableGOC = 0x1A90271D,
	CGrabThrowGOC = 0x3C23783B,
	CRespawnGOC = 0x9373FEC0,
	CSwingRopeGOC = 0xAF565E69,
	CActorInteractionGOC = 0xC7B43DA6,
	CWindWakerGOC = 0xC9ED6454,
	CCameraTargetPlayerGOC = 0x78D8893A,
	CPoiObjectGOC = 0xA86E6401,
	CSoundGOC = 0xFDD83489,
	CPerformanceGroupControllerGOC = 0xCCAD4BD9,
	CTouchSetGOC = 0x502506D6,
	CMineCartProxyGOC = 0x88603CF7,
	CWaterVolumeGOC = 0xE1E1C49C,
	CNearVisibleGOC = 0x6C5D597D,
	CSwimmerGOC = 0x3449A5DF,
	CCharacterPrimitivesCollisionGOC = 0x591D8F55,
	CRenderMethodResolverGOC = 0x90D8D3CE,
	CTriggerForceGOC = 0xBD4CFA2F,
	CFuseBombGOC = 0x3150D2F6,
	CPathControlZiplineGOC = 0xAF3A06F2,
	CPolarBearGOC = 0xD32870DF,
	CGroupSpawnGOC = 0x2131C235,
	CAnimationGridControllerGOC = 0x2751EBF2,
	CTimerAnimationGridParamProviderGOC = 0x18B96D29,
	CActionDetectorGOC = 0xB9F9F04C,
	CCameraShakerGOC = 0x343A47F7,
	CRespawnBalloonGOC = 0x06159C2D,
	CPlayerActorGOC = 0x7E6063C8,
	CTippyGOC = 0x91F22DCF,
	CCinematicCameraShotGOC = 0x89F426F2,
	CConveyorModifierGOC = 0x1EB2749F,
	CFogVolumeGOC = 0x73AECD92,
	CRetronomeGOC = 0x845E492A,
	CWaterRenderVolumeGOC = 0x23C5DFF4,
	CCinematicSkipHandlerGOC = 0x55F80CCE,
	CBonusRoomGOC = 0xAB5C5D7B,
	CTireBounceGOC = 0x3A3A6FAD,
	CBeatUpHandlerGOC = 0x9D25FE2D,
	COwlGOC = 0x9FC07D01,
	CGrabbableGeneratorGOC = 0xA42F7AB9,
	CInventoryItemGOC = 0xF34EDD1F,
	CEndGameGOC = 0x18C0AD0F,
	CRocketBarrelProxyGOC = 0xEBE92100,
	CBurningBranchGOC = 0xB7ADA3EC,
	CHotCoalsGOC = 0x59AB515E,
	CBarrelBalloonGOC = 0xE21D45CB,
	CUVTransformGOC = 0x6302BBB3,
	CBaboonGOC = 0x5FEF037B,
	CMusicDataGOC = 0x25899782,
	CMusicStateControllerGOC = 0x1AC8C8FD,
	CMusicSystemTransportGOC = 0x47A60DC3,
	CAdapterManagerGOC = 0x5CF17BFE,
	CWaterRenderDecalGOC = 0xCA08C6A4,
	CRelayAutoFireGOC = 0x7F6D1CBA,
	CBaboonManagerGOC = 0x3DAAF68B,
	CGraphicalTransitionGOC = 0xD745DC42,
	CRetronomeDriverGOC = 0x0FA3899C,
	CEndLevelGOC = 0x57E54B9D,
	CSuperCombinedAbilityEmitterGOC = 0x6780941E,
	CSuperCombinedAbilityResponderGOC = 0xB8B6A22E,
	CMapPlayerGOC = 0x0AF8D63C,
	CMapPathControlGOC = 0x8CB5BF7D,
	CWaterCurrentVolumeGOC = 0xEBE0DAEE,
	CCausticVolumeGOC = 0xA7D1C922,
	CPufferFishGOC = 0x35D8F3F0,
	CPlaylistGOC = 0xBA796FEF,
	CWindWakerImpulserGOC = 0xC2F2282A,
	CMapNodeGOC = 0xE03DD39F,
	CRambiCrateGOC = 0x55AAB5F1,
	CAudioEffectGOC = 0x24D9D323,
	CDSPGOC = 0xF7602744,
	CRoomSettingsGOC = 0x160E9AF9,
	CDynamicActorControlGOC = 0x5746A908,
	CHUDAnchorGOC = 0x59276E0E,
	CTimeKeyframeGOC = 0xF442A668,
	CRelayProbabilityGameModeGOC = 0xB6040870,
	CFlyingPickupEffectGOC = 0xF3847DE3,
	CSimpleShadowGOC = 0x212BCDF5,
	CAudioBusControllerGOC = 0x655C5175,
	CPlayerKeyframeGOC = 0xF6751A5D,
	CBreathMonitorGOC = 0xC04DAF13,
	CDirectionalIrradianceProbesGOC = 0x4C7B9FC8,
	CSurfaceControlGOC = 0x0BE7FC29,
	CSimpleSoundGOC = 0xB6EC1A51,
	CLightGroupProxyGOC = 0xD2CAC9A5,
	CDialogPanelGOC = 0xDFD2A23A,
	CMinecartPathManagerGOC = 0xBCCB1B30,
	CImpostorGOC = 0xD856F6B9,
	CLevelDarkenerGOC = 0xBD040603,
	CRenderGroupGOC = 0xA72A9926,
	CRenderToFlashGOC = 0x3258FD44,
	CSkinSwapGOC = 0x3ABCFF68,
	CScreenCaptureToFlashGOC = 0xC532AD25,
	CPlayerSoundGOC = 0xB152AD59,
	CStreamedMovieGOC = 0xBFF963D2,
	CBloomEffectGOC = 0x7DCAF170,
	CProjectedSimpleShadowReceiverGOC = 0x1243C3E3,
	CShopDataGOC = 0x5368FF52,
	CShopInstanceGOC = 0xA04F0C68,
	CUICameraSelectorGOC = 0x5B0C954B,
	CSquawksGOC = 0x7CC0B7BF,
	CSquawksProxyGOC = 0xB177FA02,
	CLoadUnitControllerGOC = 0x4C53A836,
	CFlashTextureSwapperGOC = 0x008E3AF5,
	CExtrasGOC = 0xF5D80D1A,
	CExtrasTypeGOC = 0xBB449D71,
	CExtrasCategoryGOC = 0xA98F9015,
	CDynamicLoadManagerGOC = 0xEE0D6FD4,
	CMapManagerProxyGOC = 0xFDDB58A1,
	CAchievementGOC = 0xA32E718F,
	CAudioBusMixerGOC = 0x62913993,
	CCreditsGOC = 0xADCD416E,
	CHUDFadeDetectorGOC = 0xA4E4FE1D,
	CProductionFrontEndProxyGOC = 0xAF9DEA76,
} DKCTF_CRC;

typedef struct
{
    //Todo, add check for DKCTF and MP1R, use the right hashes
    DKCTF_CRC FieldNameHash;
    uint16 blockSize;
    byte theFieldBlock[blockSize];
} Field;

typedef struct
{
    uint16 typeID;
    uint16 version;
} GenericAssetHeader;

typedef struct
{
    Vector3_F32 min;
    Vector3_F32 max;
} AABox;

typedef enum <ubyte>
{
    Bool,
    F32,
    I32,
    Unk,
} ValueType;

typedef enum <ubyte>
{
    LessThan,
    LessThanOrEqualTo,
    EqualTo,
    GreaterThanOrEqualTo,
    GreaterThan,
} ComparisionOperator;

typedef struct
{
    //uint32 unk;
    uint32 unk;
    uint32 alloc;
    uint32 headerSize;
    uint32 dataAlign;
    uint32 cDataOff;
    uint32 cDataSize;
    uint32 dSize;
    uint32 cSize;
    uint32 compOff;
    //FSkip(4);
} TextureMetadata;

typedef struct
{
    DataType hdr;
    /*if (dontCheckForLE != 1)
    {
        FSkip(-4);
        uint32 hdrChecker<hidden=true>;
        if (hdrChecker == 538976266)
        {
            LittleEndian();
        }
        dontCheckForLE = 1;
    }*/
    uint64 dataSize;
    uint64 unk; //pad?
    DataType contentType;
    uint32 fVer;
    uint32 dVer;
} FormDescriptor<bgcolor=cGreen>;

typedef enum <uint32>
{
    CafeLZSS_Uncompressed,
    CafeLZSS_8Bit,
    CafeLZSS_16Bit,
    CafeLZSS_32Bit,
    NX_Zlib = 13,
} CompressionMode;

typedef struct
{
    DataType contentType;
    uint64 dataSize;
    uint32 unk; //pad?
    uint64 dataOff;
} ChunkDescriptor<bgcolor=cGreen>;

typedef struct
{
    if (isPack)
    {
        FormDescriptor MessageTableFormDesc;
    }
    if (isPack != 1)
    {
        if (isNX == 0)
        {
            if (ContentForm.fVer == 5 && ContentForm.dVer == 5)
            {
                isNX = 1;
                Printf("NX FILE DETECTED");
            }
        }
    }
    struct MessageTable
    {
        for (i = 0; i < 9; i++) //DKCTF has 9 localizations
        {
            struct Language
            {
                ChunkDescriptor MessageTableChunkDesc;
                byte   NMSBinTextFile[MessageTableChunkDesc.dataSize]; //Literally Nintendy's message fmt
            } messLng<bgcolor=cGreen>;
        }
    } messageTable;
} MessageTableChunk;

typedef struct
{
    if (isSDX != 1) //fix for material arc
    {
        FormDescriptor MaterialForm;
    }
    //struct SPlatformData
    //{
        ChunkDescriptor ShaderPlatformChunkDesc;
        //WIP!
        //U32_Bool useTOC;
        /*if (useTOC == 1)
        {
            Printf("TOC is not yet supported!");
            break;
        }*/
        /*
        {
            uint32 TOCSize;
            struct MaterialArchiveTOC
            {
                uint32 shaderSourceTocCnt;
                struct ShaderSourceTocEntries
                {
                    for (i = 0; i < shaderSourceTocCnt; i++)
                    {
                        struct ShaderSourceTocEntry
                        {
                            uint32 unk1;
                            uint32 unk[4];
                        } sste;
                    }
                } sstes;
                //uint32 MTRLTocCnt;
                //uint32 MTRLTocEntry[MTRLTocCnt];
            } mtrlArcToc;
            //byte TOC[TOCSize];
            //
        }*/
        /*uint32 shaderParts;
        struct ShaderParts
        {
            for (i = 0; i < shaderParts; i++)
            {
                struct ShaderPart
                {
                    Byte_Bool state;
                    byte unk;
                    uint32 dSize;
                    byte shader[dSize];
                } sp;
            }
        } sps;
        uint32 shaderMaterialInputDescs;
        struct ShaderMaterialInputDescriptions
        {
            for (i = 0; i < shaderMaterialInputDescs; i++)
            {
                struct ShaderMaterialInputDesc
                {
                    MaterialType theMaterial;
                    uint16 unk;
                    uint32 shaderImportDescs;
                    struct ShaderImportDescs
                    {
                        for (i2 = 0; i2 < shaderImportDescs; i2++)
                        {
                            struct ShaderImportDesc
                            {
                                uint64 shaderID;
                                uint32 shaderPartIdxVertShader;
                                uint32 shaderPartIdxFragShader;
                                uint32 shaderPartIdxGeomShader;
                                uint32 dmy;
                                struct ShaderDefines
                                {
                                    uint32 shaderDefineStrings;
                                    for (i = 0; i < shaderDefineStrings; i++)
                                    {
                                        U32_StringEntry StringEntry;
                                    }
                                    uint32 lenOfStrings;
                                } sd;
                                uint32 additional;
                                byte additionalData[additional];
                            } sid;
                        }
                    } sids;
                } smid;
            }
        } smids;*/
        byte SPlatformData[ShaderPlatformChunkDesc.dataSize];
    //} SPlatform;
} ShaderPlatformContent;

typedef struct ShaderMaterialIdentifier
{
    MaterialType theType;
    uint32 entries;
    struct MaterialPermutations
    {
        for (i = 0; i < entries; i++)
        {
            struct MaterialPermutation
            {
                uint32 shaderID;
                uint32 permutationID;
            } mp;
        }
    } mps;
};

typedef struct
{
    ChunkDescriptor ExportChunkDescriptor;
    ShaderMaterialIdentifier theShaderMaterial;
} ExportedMaterialChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor SwooshParticleSystemFormDescriptor;
        //byte SwooshParticleSystemDescBlock[SwooshParticleSystemFormDescriptor.dataSize];
    }
    struct DescriptionChunkData
    {
        ChunkDescriptor DescriptionChunk;
        GenericAssetHeader DESCChunkAssetHdr;
        byte SwooshParticleSystemDescBlock[DescriptionChunk.dataSize-4];
    } dchd;
    //GenericAssetHeader theDescChunkHdr;
} SwooshParticleSystemChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor RuleSetConfigFormDescriptor;
        //ChunkDescriptor RSTCChunkDesc;
        //byte RuleSetConfigDataBlock[RuleSetConfigFormDescriptor.dataSize-24];
    }
    
    struct RuleSetConfigData
    {
        ChunkDescriptor RSTCChunkDesc;
        //byte RuleSetConfigDataBlock[RSTCChunkDesc.dataSize];
        //Fsr this errors out in a PAK despite it seems to work | FIX: Use i3
        
        struct Rules
        {   
            uint16 rules;
            for (i = 0; i < rules; i++)
            {
                struct Rule
                {
                    uint16 conditions;
                    struct Conditions
                    {
                        for (i3 = 0; i3 < conditions; i3++)
                        {
                            struct Condition
                            {
                                uint32 condID;
                                ComparisionOperator theComparisionOp;
                                ValueType theValueType;
                                if (theValueType == 0)
                                {
                                    I32_Bool value;
                                }
                                if (theValueType == 1)
                                {
                                    float value;
                                }
                                if (theValueType == 2)
                                {
                                    int32 value;
                                }
                                if (theValueType == 3)
                                {
                                    byte value[4];
                                }
                            } cond;
                        }
                    } conds;
                    uint16 actions;
                    struct Actions
                    {
                        for (i3 = 0; i3 < actions; i3++)
                        {
                            struct Action
                            {
                                uint32 actionID;
                                byte properties;
                                if (properties != 0)
                                {
                                    uint32 ary[properties];
                                }
                            } action;
                        }
                    } actionEntries;
                } rule;
            }
        } ruleEntries;
    } rscd;
    //ChunkDescriptor DescriptionChunk;
    //uint16 unk[2];
} RuleSetConfigChunk<bgcolor=cBlue>;

typedef struct
{
    if (isPack)
    {
        FormDescriptor ScaleformGFXLibraryFormDescriptor;
        //byte ScaleformGFXLibraryDataBlock[ScaleformGFXLibraryFormDescriptor.dataSize];
    }
    //struct GFXLibData
    //{
        ChunkDescriptor GFXLChunk;
        struct GFXLibChunkData 
        {
            uint32 referencedTextures;
            struct ReferencedTxtrs
            {
                for (i = 0; i < referencedTextures; i++)
                {
                    struct ReferencedTxtr
                    {
                        GUID texRef;
                        if (isNX == 0)
                        {
                            byte checkForNX<hidden=true>;
                            FSkip(-1);
                            if (checkForNX == 0)
                            {
                                isNX = 1;
                                Printf("NX PAK DETECTED");
                            }
                        }
                        if (isNX)
                        {
                            U32_StringEntry texName;
                        }
                        else
                        {
                            string texName;
                        }
                    } rtxtr;
                }
            } rtxrs;
            if (isNX)
            {
                U32_StringEntry theSWFName;
            }
            else
            {
                string theSWFName;
            }
            FSkip(4);
            //At least MP1R doesn't use GFX
            LittleEndian(); //temp swap endian
            uint32 swfSize<hidden=true>;
            BigEndian(); //temp swap endian
            FSkip(-8);
            byte theGFXFile[swfSize];
        } gfxcd<bgcolor=cGreen>;
    //} gfxld;
} ScaleformGFXLibraryChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor AnimationFormDescriptor;
    }
    struct AnimationData
    {
        GenericAssetHeader animHdr<bgcolor=cGreen>;
        if (isPack)
        {
            byte AnimationDataBlock[AnimationFormDescriptor.dataSize-4]<bgcolor=cRed>;
        }
        else
        {
            byte AnimationDataBlock[ContentForm.dataSize-4]<bgcolor=cRed>;
        }
    } ad;
} AnimationChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor LightProbeFormDescriptor;
        byte LightProbeDataBlock[LightProbeFormDescriptor.dataSize];
    }
    else
    {
        byte LightProbeDataBlock[ContentForm.dataSize];
    }
} LightProbeChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor FlashGFXFormDescriptor;
    }
    struct GFX
    {
        ChunkDescriptor FlashGFXChunkDescriptor;
        /*struct GFXData
        {
            GUID LibGUID;
            GUID PossiblyAnotherGUID;
            //FSkip(12);
            uint32 SWFCount;
            struct SWFEntries
            {
                for (i = 0; i < RefSWFCount; i++)
                {
                    struct SWFEntries
                    {
                        uint64 dataOff;
                        uint64 SWFSize;
                        char SWFName[48];
                    } rswfe;
                }
            } rswfes;
            //FSkip(48);
            //struct MainSWF
            //{
                //uint64 mainDataOff;
                //uint64 mainSWFSize;
                //char mainSWFName[48];
                //FSkip(dataOff-20-7);
                if (RefSWFCount == 1)
                {
                    byte theSWFFile[FlashGFXChunkDescriptor.dataSize-sizeof rswfs-36]; //add 7 since since the CWS bit is included
                }
                else
                {
                    struct SWFFiles
                    {
                        for (i = 0; i < RefSWFCount; i++)
                        {
                            struct SWFFile    
                            {
                                byte SWFFile[rswfes.rswfe[i].SWFSize];
                            } rswff;
                        }
                        //byte theSWFFile[(FlashGFXChunkDescriptor.dataSize) - (sizeof rswfs) - 100];
                    } rswffs;
                    //byte theMainSWFFile[FlashGFXChunkDescriptor.dataSize-sizeof rswfs-36]; //add 7
                }
            //} mswf;
        } gfxd;*/
        //for now read it in bytes idk how to make 010 detect the whole thing
        byte theGFXFiles[FlashGFXChunkDescriptor.dataSize]<bgcolor=cPurple>;
    } gfx;
} FlashGFXChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor FiniteStateMachineFormDescriptor;
        //ChunkDescriptor FiniteStateMachineChunkDesc;
        //byte FiniteStateMachineDataBlock[FiniteStateMachineChunkDesc.dataSize];
    }
    struct FiniteStateMachineData
    {
        ChunkDescriptor FiniteStateMachineChunkDesc;
        byte FiniteStateMachineDataBlock[FiniteStateMachineChunkDesc.dataSize]<bgcolor=cRed>;
    } fsmd;
    //for now
    
    /*ChunkDescriptor FiniteStateMachineChunkDesc;
    uint32 someCnt;
    for (i = 0; i < someCnt; i++)
    {
        struct UnknownData
        {
            string name;
            GUID theGUID; //?
        } unkd;
    }*/
} FiniteStateMachineChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor AnimationTransformFormDescriptor;
        //byte AnimationTransformData[AnimationTransformFormDescriptor.dataSize-24];
    }
    struct AnimationTransformData
    {
        ChunkDescriptor AnimationTransformChunkDescriptor;
        GenericAssetHeader AnimationTransformAssetHdr;
        byte AnimationTransformData[AnimationTransformChunkDescriptor.dataSize-4];
    } xfrmd;
    /*else
    {
        //byte AnimationTransformData[ContentForm.dataSize];
        //is meta part of this?
    }*/
} AnimationTransformChunk;

typedef struct
{
    DataType EventID;
    DataType ActionID;
    GUID componentGUID;
    uint16 unk;
    Byte_Bool unk2[2];
} Connection;

typedef struct
{
    DataType linkID;
    GUID componentGUID;
    Byte_Bool unk;
} ScriptLink;

typedef struct
{
    DataType unk1;
    DataType SubCompType;
    GUID SubCompGUID;
    byte unk2[3];
    Byte_Bool unk;
} SubComponent;

typedef struct
{
    DKCTF_CRC ComponentTypeCRC;
    if (ComponentTypeCRC == 2314479346)
    {
        //isGameObjectComponent = 1;
    }
    GUID componentGUID;
    U32_StringEntry theComponentName;
    //FSkip(16);
    //uint32 guids;
    //GUID theGUID;
    if (isGameObjectComponent == 0)
    {
        uint16 connections;
        if (connections != 0)
        {
            struct Connections
            {
                for (i = 0; i < connections; i++)
                {
                    Connection theConn;
                }
            } conns;
        }
        //We die here
        //uint32 testScriptLinksVar;
        uint32 scriptLinks;
        if (scriptLinks != 0)
        {
            struct ScriptLinks
            {
                for (i2 = 0; i2 < scriptLinks; i2++)
                {
                    Field theSL;
                }
            } slnks;
        }
    }
    else
    {
        uint16 subComponents;
        if (subComponents != 0)
        {
            struct SubComponents
            {
                for (i2 = 0; i2 < subComponents; i2++)
                {
                    SubComponent theSubComp;
                }
            } subcs;
        }
        else
        {
            FSkip(1);
        }
    }
} Component;

typedef struct
{
    ChunkDescriptor ComponentChunkDescriptor;
    byte theComponent[ComponentChunkDescriptor.dataSize]; //For now
    //Component theComponent;
    isGameObjectComponent = 0;
} GameObjectComponent;

typedef struct
{
    if (isPack)
    {
        FormDescriptor RoomFormDescriptor;
        byte RoomData[RoomFormDescriptor.dataSize]<bgcolor=cRed>;
    }
    else
    {
        byte RoomData[ContentForm.dataSize]<bgcolor=cRed>;
        //is meta part of this?
    }
    
    /*struct RoomData
    {
        struct MainHeader
        {
            FormDescriptor RoomHeaderFormDescriptor;
            struct RoomHeaderForm
            {
                struct RoomHeader
                {
                    ChunkDescriptor RoomHeaderChunkDescriptor;
                    uint16 RoomHeaderUnkU16; //Always 3
                } rhdr;
                //struct RoomHeaderData
                //{
                    //local uint16 totalLoadUnits<hidden=true> = LoadUnits+LoadUnits;
                    struct PerformanceGroup
                    {
                        ChunkDescriptor PerformanceGroupsChunkDescriptor;
                        struct PerformanceGroupEntries
                        {
                            uint16 pgcount;
                            for (i = 0; i < pgcount; i++)
                            {
                                struct PerformanceGroupEntry
                                {
                                    U32_StringEntry groupName;
                                    GUID editorID;
                                    Byte_Bool active;
                                    uint16 refLayerGUIDs;
                                    if (refLayerGUIDs != 0)
                                    {
                                        struct ReferencedLayerGUIDs
                                        {
                                            for (i2 = 0; i2 < refLayerGUIDs; i2++)
                                            {
                                                struct ReferencedLayerGUID
                                                {
                                                    GUID theRefGUID;
                                                } rlyrguid;
                                            }
                                        } rlyrguids;
                                    }
                                } pge;
                            }
                        } pges;
                    } pgc;
                    struct LevelGenerated
                    {
                        ChunkDescriptor LevelGeneratedChunkDescriptor;
                        struct LevelGeneratedData
                        {
                            uint16 objCount;
                            if (objCount != 0)
                            {
                                struct GeneratedObjects
                                {
                                    for (i = 0; i < objCount; i++)
                                    {
                                        struct GenObject
                                        {
                                            GUID GenObjectID;
                                            GUID LyrID;
                                        } gobj;
                                    }
                                } gobjs;
                            }
                        } lgd;
                    } lg;
                    struct LoadUnitForms
                    {
                        for (i = 0; i < 20; i++)
                        {
                            if (terminateLoadUnitDetection != 1)
                            {
                                struct LoadUnitForm
                                {
                                    FormDescriptor LoadUnitFormsFormDescriptor;
                                    struct LoadUnitFormsData
                                    {
                                        struct LevelUnitHead
                                        {
                                            ChunkDescriptor LevelUnitHeadDescriptor;
                                            struct LevelUnitHeaderData
                                            {
                                                U32_StringEntry theStr;
                                                GUID loadUnitGUID;
                                                uint16 flags;
                                            } LUHD;
                                        } LUH;
                                        struct LevelUnitResources
                                        {
                                            ChunkDescriptor LevelUnitResourcesChunkDescriptor;
                                            struct LevelUnitResourcesData
                                            {
                                                uint32 resCnt;
                                                if (resCnt != 0)
                                                {
                                                    struct LevelUnitResIDs
                                                    {
                                                        for (i = 0; i < resCnt; i++)
                                                        {
                                                            struct LevelUnitResID
                                                            {
                                                                GUID LevelResID;
                                                            } luri;
                                                        } 
                                                    } lurids;
                                                }
                                            } luresids;
                                        } lres;
                                        struct LevelUnitLayers
                                        {
                                            ChunkDescriptor LevelUnitLayersChunkDescriptor;
                                            struct LevelUnitLayersData
                                            {
                                                uint32 layerCount;
                                                local uint32 totalLayerCount = layerCount+layerCount;
                                                //Printf("%i\n", totalLayerCount);
                                                if (layerCount != 0)
                                                {
                                                    struct LevelUnitLayerEntries
                                                    {
                                                        for (i = 0; i < layerCount; i++)
                                                        {
                                                            struct LevelUnitLayerEntry
                                                            {
                                                                GUID LevelResID;
                                                            } lari;
                                                        } 
                                                    } larids;
                                                }
                                            } lulids;
                                        } lulres;
                                    } luf;
                                } lufd;
                                FSkip(20);
                                DataType checkForLUNT<hidden=true>;
                                FSkip(-24);
                                if (checkForLUNT != LoadUnitChunk)
                                {
                                    terminateLoadUnitDetection = 1;
                                    Printf("End of Load Units!\n");
                                }
                            }
                        }
                        terminateLoadUnitDetection = 0;
                    //} rhd;
                } lufds;
            } mhd;
        } mh;
        //Hell begins
        Printf("Script Layers: %i\n", mh.mhd.lufds.lufd.luf.lulres.lulids.totalLayerCount);
        struct ScriptLayers
        {
            for (i2 = 0; i2 < mh.mhd.lufds.lufd.luf.lulres.lulids.totalLayerCount; i2++)
            {
                struct ScriptLayer
                {
                    FormDescriptor ScriptLayersFormDescriptor;
                    struct ScriptLayerData
                    {
                        struct LayerHeader
                        {
                            ChunkDescriptor ScriptLayerHeadChunkDescriptor;
                            struct LayerHeaderData
                            {
                                U32_StringEntry ScriptLayerName;
                                GUID ScriptLayerGUID;
                                uint16 unk;
                                uint16 loadUnitIDs;
                                if (loadUnitIDs != 0)
                                {
                                    struct LoadUnitIDs
                                    {
                                        for (i = 0; i < loadUnitIDs; i++)
                                        {
                                            struct LoadUnitGUIDEntry
                                            {
                                                GUID LoadUnitGUID;
                                            } luge;
                                        }
                                    } luids;
                                }
                                GUID unknownGUID;
                                Byte_Bool unknownFlag;
                            } lyrhdrd;
                        } lyrhdr;
                        struct GeneratedScriptObject
                        {
                            FormDescriptor GeneratedScriptObjFormDescriptor;
                            if (GeneratedScriptObjFormDescriptor.dataSize != 0)
                            {
                                for (i = 0; i < 255; i++)
                                {
                                    if (terminateGameObjDetection != 1)
                                    {
                                        struct GenGameObjData
                                        {
                                            ChunkDescriptor GenGameObjChunkDesc;
                                            GUID objID;
                                            uint16 componentCount;
                                            struct GameObjectComponents
                                            {
                                                for (i = 0; i < componentCount; i++)
                                                {
                                                    GameObjectComponent theComponent;
                                                }
                                            } gobjcs;
                                            DataType checkForRFRM<hidden=true>;
                                            FSkip(-4);
                                            if (checkForRFRM == RUDEFormDescriptor)
                                            {
                                                terminateGameObjDetection = 1;
                                                Printf("End of Generated Game Objects!\n");
                                            }
                                        } ggobjd;
                                    }
                                }
                            }
                        } gso;
                        terminateGameObjDetection = 0;
                        struct ScriptObject
                        {
                            FormDescriptor ScriptObjectFormDescriptor;
                            if (ScriptObjectFormDescriptor.dataSize != 0)
                            {
                                struct Data
                                {
                                    for (i = 0; i < 2000; i++)
                                    {
                                        if (terminateGameObjDetection != 1)
                                        {
                                            {
                                                GameObjectComponent theGOBJ;
                                            }
                                            DataType checkForRFRM<hidden=true>; //if we error out here from standalone files, we're fine
                                            FSkip(-4);
                                            if (checkForRFRM == RUDEFormDescriptor)
                                            {
                                                terminateGameObjDetection = 1;
                                                Printf("End of Game Objects!\n");
                                            }
                                    
                                        }
                                    }
                                } d;
                            }
                            //i = 0;
                        } sro;
                        terminateGameObjDetection = 0;
                    } sld;
                } sl;
            }
        } sld;
    } rd;*/
} RoomChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor CharacterChunkFormDescriptor;
        //byte CharacterChunkData[CharacterChunkFormDescriptor.dataSize];
    }
    /*else
    {
        byte CharacterData[ContentForm.dataSize];
        //is meta part of this?
    }*/
    struct CharacterData
    {
        GenericAssetHeader theCharChunkAssetHdr<bgcolor=cGreen>;
        byte CharacterData[CharacterChunkFormDescriptor.dataSize-4]<bgcolor=cRed>;
        /*struct CharInfo
        {
            byte unk[16];
            byte flags[3];
        } charInfo;
        string theName;
        GUID skelObjectID;
        int32 charModelSets;
        struct CharModelSets
        {
            for (i = 0; i < charModelSets; i++)
            {
                struct CharModelSet
                {
                    string charModelName;
                    GUID SMDLGUID;
                    AABox charModelSetAABox;
                } cms;
            }
        } cmss;
        int32 charAnimInfos;
        struct CharAnimInfos
        {
            for (i = 0; i < charAnimInfos; i++)
            {
                struct CharAnimInfo
                {
                    string charModelName;
                    GUID SMDLGUID;
                    uint32 unk[2];
                    uint16 unk2[2];
                    byte unk3;
                    AABox charAnimAABox;
                } cmi;
            }
        } cmis;
        struct AnimIDMap
        {
            int32 hashNodes;
            for (i = 0; i < hashNodes; i++)
            {
                int32 hashNode;
            }
        } aim;
        AABox mainAABox;*/
    } charData;
} CharacterChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor SkeletonDataFormDescriptor;
    }
    struct SkeletonData
    {
        GenericAssetHeader theSkeletonDataHdr<bgcolor=cGreen>;
        if (isPack)
        {
            //FSkip(-32);
            byte SkeletonData[SkeletonDataFormDescriptor.dataSize-4]<bgcolor=cRed>;
        }
        else
        {
            byte SkeletonData[ContentForm.dataSize-4]<bgcolor=cRed>;
        }
        /*
        struct JointNameArray
        {
            uint32 unk;
            uint32 jointNames;
            struct JointNames
            {
                for (i = 0; i < jointNames; i++)
                {
                    //struct JointName
                    //{
                        U32_StringEntry JointNameStr;
                    //} jn;
                }
            } jn;
        } jna;*/
    } skd;
} SkeletonChunk;

typedef struct
{
    if (isPack == 1 && !isCLSN)
    {
        FormDescriptor MTRLFormDescriptor;
    }
    if (ContentForm.fVer == 10 && ContentForm.fVer == 10)
    {
        isSDX = 1;
        ChunkDescriptor MTRLChunkDesc;
        struct ShaderArcData
        {
            byte theFile[MTRLChunkDesc.dataSize];
            ShaderPlatformContent ShaderPlatformChunk;
        } mtrld<bgcolor=cRed>;
    }
    else
    {
        if (isCLSN)
        {
            ChunkDescriptor MTRLClsnChunkDesc;
            struct MTRLClsnData
            {
                uint32 collisionMaterialCount;
                for (i = 0; i < collisionMaterialCount; i++)
                {
                    struct CollisionMaterial
                    {
                        uint32 unk[5];
                    } clm;
                }
                //byte theFile[MTRLClsnChunkDesc.dataSize];
            } mtrld;
        }
        else
        {
            //struct MaterialData
            //{
                uint16 zlibCheck<hidden=true>;
                FSkip(-2);
                if (zlibCheck == 30938)
                {
                    if (isPack)
                    {
                        byte theZlibCompressedFile[MTRLFormDescriptor.dataSize]<bgcolor=cPurple>;
                    }
                    else
                    {
                        byte theZlibCompressedFile[ContentForm.dataSize]<bgcolor=cPurple>;
                    }
                }
                else
                {
                    ExportedMaterialChunk theEXPT;
                    /*struct MaterialIdentifier
                    {
                        
                    } mi;*/
                    ShaderPlatformContent PlatChunk;
                }
            //} mtrld;
        }
    }
} MaterialChunk<bgcolor=cPurple>;

typedef struct
{
    uint32 indiceX;
    uint32 indiceY;
    uint32 indiceZ;
    if (isCLSN && isLegacyCLSN != 1)
    {
        uint16 idx;
        uint16 unk;
    }
} CollisionTriangle;

typedef struct
{
    //float min_4;
    AABox LeafNodeAABox;
    //float max_4;
    if (tree_forDCLN == 0)
    {
        uint32 unk1;
        uint32 unk2;
        uint32 unk3;
    }
    else
    {
        float unk1;
        float unk2;
        float unk3;
    }
} LeafNode;

typedef struct
{
    ChunkDescriptor VerticesChunkDescriptor;
    struct VertexData
    {
        uint32 Vertexes;
        for (i = 0; i < Vertexes; i++)
        {
            Vector3_F32 vtx;
        }
    } vtxd<bgcolor=cGreen>;
} VerticesChunk;

typedef struct
{
    ChunkDescriptor TrianglesChunkDescriptor;
    struct TriangleData
    {
        uint32 TriangleCount;
        for (i = 0; i < TriangleCount; i++)
        {
            CollisionTriangle theCollisionTriangle;
        }
    } triData<bgcolor=cPurple>;
} TrianglesChunk;

typedef struct
{
    local string extensionToAdd<hidden=true> = "";
    DataType AssetType;
    if (AssetType == DependencyGroup)
    {
        DependencyGroups++;
    }
    //Add true ext names from log in Kiosk
    if (AssetType == MessageTable_MessageStudioBinaryText)
    {
        extensionToAdd = "mstbin";
        addExtension = 1;
    }
    if (AssetType == LooseData)
    {
        extensionToAdd = "ldata";
        addExtension = 1;
    }
    if (AssetType == UniverseInfo)
    {
        extensionToAdd = "uinfo";
        addExtension = 1;
    }
    if (AssetType == CookedAudioBusHeiarchy)
    {
        extensionToAdd = "cabh";
        addExtension = 1;
    }
    if (AssetType == Material)
    {
        extensionToAdd = "cmat";
        addExtension = 1;
    }
    if (AssetType == Character)
    {
        extensionToAdd = "char";
        addExtension = 1;
    }
    if (AssetType == CookedAudioSample)
    {
        extensionToAdd = "csmp";
        addExtension = 1;
    }
    if (AssetType == FiniteStateMachine)
    {
        extensionToAdd = "cfsm";
        addExtension = 1;
    }
    if (AssetType == FlashGFX)
    {
        extensionToAdd = "rfgfx";
        addExtension = 1;
    }
    if (AssetType == ScaleformGFXLibrary)
    {
        extensionToAdd = "rsgfx";
        addExtension = 1;
    }
    if (AssetType == CookedAudioSoundEffect)
    {
        extensionToAdd = "caud";
        addExtension = 1;
    }
    if (AssetType == Room)
    {
        extensionToAdd = "rsd";
        addExtension = 1;
    }
    if (AssetType == Texture)
    {
        extensionToAdd = "ctex/ctexarray/ctex3d"; //There's also ctexarray and ctex3d but how is that determined
        addExtension = 1;
    }
    GUID AssetID;
    if (isNX == 0) //If this is 0, it's an NX PAK
    {
        byte checkForNX<hidden=true>;
        FSkip(-1);
        if (checkForNX == 0)
        {
            isNX = 1;
            Printf("NX PAK DETECTED\n");
        }
    }
    if (isNX)
    {
        U32_StringEntry AssetName;
        if (addExtension)
        {
            if (AssetType == MessageTable_MessageStudioBinaryText)
            {
                Printf("%s%s.%s\n", MessageTableBinDir, AssetName.theString, extensionToAdd);
            }
            else if (AssetType == FlashGFX || AssetType == ScaleformGFXLibrary)
            {
                Printf("%s%s.%s\n", GFXDir, AssetName.theString, extensionToAdd);
            }
            else if (AssetType == LooseData)
            {
                Printf("%s%s.%s\n", LooseDataTweaksDir, AssetName.theString, extensionToAdd);
            }
            else if (AssetType == CookedAudioBusHeiarchy)
            {
                Printf("%s%s.%s\n", AudioDir, AssetName.theString, extensionToAdd);
            }
            else if (AssetType == UniverseInfo)
            {
                Printf("%s%s.%s\n", WorldDir, AssetName.theString, extensionToAdd);
            }
            else
            {
                Printf("%s.%s\n", AssetName.theString, extensionToAdd);
            }
        }
        else
        {
            Printf("%s\n", AssetName.theString);
        }
    }
    else
    {
        string AssetName;
        if (addExtension)
        {
            if (AssetType == MessageTable_MessageStudioBinaryText)
            {
                Printf("%s%s.%s\n", MessageTableBinDir, AssetName, extensionToAdd);
            }
            else if (AssetType == FlashGFX || AssetType == ScaleformGFXLibrary)
            {
                Printf("%s%s.%s\n", GFXDir, AssetName, extensionToAdd);
            }
            else if (AssetType == LooseData)
            {
                Printf("%s%s.%s\n", LooseDataTweaksDir, AssetName, extensionToAdd);
            }
            else if (AssetType == CookedAudioBusHeiarchy)
            {
                Printf("%s%s.%s\n", AudioDir, AssetName, extensionToAdd);
            }
            else if (AssetType == UniverseInfo)
            {
                Printf("%s%s.%s\n", WorldDir, AssetName, extensionToAdd);
            }
            else
            {
                Printf("%s.%s\n", AssetName, extensionToAdd);
            }
        }
        else
        {
            Printf("%s\n", AssetName);
        }
    }
    addExtension = 0;
} NameTagChunk;

typedef struct
{
    ChunkDescriptor NameTagChunkDescriptor;
    uint32 nameTagCount;
    for (i = 0; i < nameTagCount; i++)
    {
        NameTagChunk theNameTag;
    }
} NameTagsChunk;

typedef struct
{
    DataType assetType;
    /*if (assetType == Texture)
    {
        hasTXTRMeta = 1;
    }*/
    GUID assetID;
    uint64 off;
    uint64 size;
} AssetEntry;

typedef struct AssetEntries
{
    int32 assetCount;
    for (i = 0; i < assetCount; i++)
    {
        AssetEntry theAssetEntry;
    }
} AssetEntries;

typedef struct
{
    ChunkDescriptor AssetDirChunkDescriptor;
    AssetEntries AssetEntriesChunk;
} AssetDirectory;

typedef struct
{
    ChunkDescriptor TreeChunkDesc;
    struct TreeData
    {
        uint32 LeafNodes;
        //struct Ver
        for (i = 0; i < LeafNodes; i++)
        {
            LeafNode theLeafNode;
            //if TreeChunkDesc
            //LeafNode theExLeafNode;
        }
        if (tree_forDCLN == 1)
        {
            tree_forDCLN = 0;
            for (i = 0; i < LeafNodes; i++)
            {
                LeafNode theDCLNLeafNode;
                //if TreeChunkDesc
                //LeafNode theExLeafNode;
            }
        }
    } treeData<bgcolor=cPurple>;
} TreeChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor LooseDataFormDescriptor;
        //ChunkDescriptor LooseDataChunkDescriptor;
        //byte LooseDataBlock[LooseDataFormDescriptor.dataSize-24];
    }
    else
    {
        //byte LooseDataBlock[ContentForm.dataSize];
    }
    //For now
    struct LooseDataBlock_SldrGameControls
    {
        ChunkDescriptor LooseDataChunkDescriptor;
        struct LooseDataBlockContent
        {
            uint16 fieldCount;
            for (i = 0; i < fieldCount; i++)
            {
                Field theField;
            }
        } ldbc<bgcolor=cPurple>;
    } LooseDataBlock;
} LooseDataChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor DependencyGroupFormDescriptor;
    }
    struct DependencyGroupData
    {
        uint32 dependenciesCnt;
        struct Dependencies
        {
            for (i = 0; i < dependenciesCnt; i++)
            {
                struct Dependency
                {
                    DataType resID;
                    GUID AssetID;
                } dependency;
            }
        } dependencies;
    } dgd<bgcolor=cGreen>;
} DependencyGroupChunk;

typedef struct
{
    ChunkDescriptor MetaDataChunkDescriptor;
    struct MetaData
    {
        if (MetaDataChunkDescriptor.dataOff != 0)
        {
            uint32 metaDataEntryCount;
            struct MetaDataOffsetEntries
            {
                for (i = 0; i < metaDataEntryCount; i++)
                {
                    struct MetaDataOffsetEntry
                    {
                        GUID AssetID;
                        uint32 metaDataOff;
                    } metaDataOffEntry;
                }
            } mdos;
            /*for (i2 = 0; i2 < metaDataEntryCount; i2++)
            {
                struct ChunkMeta
                {
                    if (AssetDirChunk.AssetEntriesChunk.theAssetEntry[i2].assetType == Texture)
                    {
                        TextureMetadata theTmt;
                    }
                } cm;
            }*/
            byte metaDataBlock[MetaDataChunkDescriptor.dataSize-sizeof mdos-4]; //For now
        }
        else
        {
            byte metaDataBlock[MetaDataChunkDescriptor.dataSize];
        }
    } metaDataContent;
} MetaDataChunk;

typedef struct
{
    ChunkDescriptor GPU;
    struct GPUChunkData
    {
        //So now I probably have to fix this for MP1R, fun
        //temp swap
        LittleEndian();
        CompressionMode theCompressionMode; 
        //swap back
        BigEndian();
        byte theCompressedContent[GPU.dataSize-4];
    } GPUChunkContent;
} GPUChunk<bgcolor=cPurple>;

typedef struct
{
    if (isPack)
    {
        FormDescriptor TextureFormDescriptor;
    }
    if (isPack == 0 && ContentForm.fVer == 15 && ContentForm.dVer == 16)
    {
        checkLocalMETA = 1;
    }
    struct TextureData
    {
        struct TextureHeader
        {
            ChunkDescriptor TextureHeaderDescriptor;
            struct TextureHeaderData
            {
                TexType texType;
                TexFmt texFmt;
                //Printf("%i:%i\n", i2, texFmt);
                uint32 width;
                uint32 height;
                uint32 depth;
                uint32 tileMode;
                uint32 swizzle;
                uint32 mips;
                uint32 mipSizes[mips];
                struct TextureSamplerData
                {
                    uint32 flags;
                    byte texFilter;
                    byte texWrap[3];
                } tsd;
            } thdrd<bgcolor=cGreen>;
        } thdr;
        GPUChunk theCPUChunk;
    } txtr; //wip
} TextureChunk;

typedef struct
{
    ChunkDescriptor ModelHeaderDescriptor;
    struct ModelHeaderContent
    {
        byte MDLHdrContent[ModelHeaderDescriptor.dataSize];
        //Broken on Skinned Models
        /*uint32 opaqueMeshes;
        uint32 onePassMeshes;
        uint32 twoPassMeshes;
        uint32 oneBitMeshes;
        uint32 additiveMeshes;
        AABox theModelHdrAABox;
        uint32 mdlDataSources;
        for (i = 0; i < mdlDataSources; i++)
        {
            uint32 type;
        }*/
    } mdc<bgcolor=cRed>;
} ModelHeaderChunk;

typedef struct
{
    DataType AROTMagic;
    uint32 unk[4];
    AABox theAABox;
    uint32 unkCount;
    uint32 unkUInt32s[unkCount];
    uint32 unkCount2;
    uint32 unkUInt32s2[unkCount2];
    uint32 unkCount3;
    byte   unkBytes[unkCount3];
    uint32 aaboxesCount;
    struct AABoxes
    {
        for (i = 0; i < aaboxesCount; i++)
        {
            AABox theAABox;
        }
    } aaboxes;
} Octree;

typedef struct
{
    ChunkDescriptor WorldModelHeaderDescriptor;
    struct WorldModelHeaderContent
    {
        byte unk;
        Octree theOctree;
        uint32 mainAABoxesCount;
        struct MainAABoxes
        {
            for (i = 0; i < mainAABoxesCount; i++)
            {
                AABox theMainAABox;
            }
        } mainaaboxesstruct;
        uint32 unknownFloatCount;
        struct UnknownFloats
        {
            for (i = 0; i < unknownFloatCount; i++)
            {
                float unknownFloat;
            }
        } unknownfloats;
    } wmdc;
} WorldModelHeaderChunk;

typedef struct
{
    ChunkDescriptor MTRLSub;
    struct MtrlSubContent
    {
        /*uint32 materials;
        struct Materials
        {
            for (i = 0; i < materials; i++)
            {
                if (isNX)
                {
                    U32_StringEntry theStr;
                }
                else
                {
                    string theStr;
                }
                GUID materialGUID;
                MaterialType matType;
                uint32 materialFlags;
                uint32 matDataCount;
                struct SubMaterialData
                {
                    for (i2 = 0; i2 < matDataCount; i2++)
                    {
                        struct SubMatDataEntry
                        {
                            uint32 dataID;
                            uint32 type;
                            if (type == 0)
                            {
                                GUID theTexAssetID;
                                uint32 flags;
                                uint32 filter;
                                uint32 wrap[3];
                            }
                            if (type == 1)
                            {
                                float matColorData[4];
                            }
                            if (type == 2)
                            {
                                float matScalarData;
                            }
                        } sme;
                    }
                } mtrld;
            }
        } mtrls;*/
        byte mtrlSubData[MTRLSub.dataSize]<bgcolor=cRed>;
    } mtrlSubContent;
} MaterialSubChunk;

typedef struct
{
    ChunkDescriptor MeshHdr;
    struct MeshContent
    {
        uint32 entries;
        struct RenderMeshes
        {
            for (i = 0; i < entries; i++)
            {
                struct RenderMesh
                {
                    uint32 primMode;
                    uint16 mtrlCacheIdx;
                    byte vertBufIdx;
                    byte idxBufIdx;
                    uint32 idxBufOff;
                    uint32 count;
                    uint16 unk;
                    byte unk54[2];
                    byte flags;
                } rmsh;
            }
        } rmshes;
    } meshContent<bgcolor=cBlue>;
} MeshChunk;

typedef struct
{
    ChunkDescriptor VertexBuffHdr;
    struct VertexBuffContent
    {
        /*uint32 entries;
        for (i = 0; i < entries; i++)
        {
            struct VertexBuffer
            {
                uint32 vtxBuffCnt;
            } vtxB;
        }*/
        byte vtxData[VertexBuffHdr.dataSize]<bgcolor=cRed>;
    } vtxBContent;
} VertexBufferChunk;

typedef struct
{
    ChunkDescriptor IndexBuffHdr;
    struct IndexBuffContent
    {
        uint32 entries;
        for (i = 0; i < entries; i++)
        {
            uint32 idxBuf;
        }
        //byte idxBData[IndexBuffHdr.dataSize];
    } idxBContent<bgcolor=cGreen>;
} IndexBufferChunk;

typedef struct
{
    ChunkDescriptor SkinnedModelHeaderDescriptor;
    struct SkinnedModelHeaderContent
    {
        uint32 unk;
    } s;
} SkinnedModelHeaderChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor ModelFormDescriptor;
    }
    struct ModelChunkData
    {
        if (isWMDL)
        {
            WorldModelHeaderChunk WorldModelHeader;
            isWMDL = 0;
        }
        if (isSMDL)
        {
            SkinnedModelHeaderChunk SkinnedModelHeader;
            isSMDL = 0;
        }
        ModelHeaderChunk ModelHeader;
        MaterialSubChunk MaterialSub;
        MeshChunk MeshData;
        VertexBufferChunk VertexBufferData;
        IndexBufferChunk IndexBufferData;
        GPUChunk GPUModelData;
    } mcd;
    //wip
} ModelChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor CABHFormDescriptor;
        byte theFile[CABHFormDescriptor.dataSize]<bgcolor=cRed>;
    }
    else
    {
        byte theFile[ContentForm.dataSize]<bgcolor=cRed>;
    }
} CookedAudioBusHeirachyChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor CSMPFormDescriptor;
        //byte theFile[CSMPFormDescriptor.dataSize];
    }
    else
    {
        //byte theFile[ContentForm.dataSize];
    }
    struct AudioSampleData
    {
        DataType lablCheck<hidden=true>;
        FSkip(-4);
        if (lablCheck == 1279345228)
        {
            struct LABLChunk
            {
                ChunkDescriptor LABLChunkDesc;
                byte LABLData[LABLChunkDesc.dataSize]<bgcolor=cRed>;
            } LABL;
        }
        struct FMTAChunk
        {
            ChunkDescriptor FMTAChunkDesc;
            byte FMTAData[FMTAChunkDesc.dataSize]<bgcolor=cRed>;
        } FMTA;
        struct DATAChunk
        {
            ChunkDescriptor DATAChunkDesc;
            byte DSPAudioData[DATAChunkDesc.dataSize]<bgcolor=cRed>;
        } DATA;
    } asd;

    //TEMP
    /*struct DATAChunk
    {
        ChunkDescriptor DATAChunkDesc;
        struct DSPAudioData
        {
            /*byte unk[3];
            uint32 samples;
            uint32 adpcmNibbles;
            //uint32 unk;
            //FSkip(11);
            uint32  sampleRate;
            uint16 loop;
            uint16 fmt;
            uint32 loopStart;
            uint32 loopEnd;
            uint32 curAddr;
            int16 decodeCoeffs[32];
            uint16 gain;
            uint16 initPredictor[2];
            byte DSPAudioData[DATAChunkDesc.dataSize]; //
        } dsp;
    } DATA;*/
} CookedAudioSampleChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor CAUDFormDescriptor;
        if (isNX)
        {
            U32_StringEntry macroFileName<hidden=true>;
            //Recover the filename
            Printf("%s.caud\n", macroFileName.theString);
        }
        else
        {
            string macroFileName<hidden=true>;
            //Recover the filename
            Printf("%s.caud\n", macroFileName);
        }
        FSkip(-sizeof macroFileName);
        //Printf("%s.caud\n", macroFileName);
        byte CookedAudioSoundEffectData[CAUDFormDescriptor.dataSize]<bgcolor=cRed>;
    }
    else
    {
        if (isNX)
        {
            U32_StringEntry macroFileName;
        }
        else
        {
            string macroFileName;
        }
        FSkip(-sizeof macroFileName);
        Printf("%s.caud\n", macroFileName);
        byte CookedAudioSoundEffectData[ContentForm.dataSize];
    }
    //TODO FIX
    /*
    if (isPack)
    {
        FormDescriptor CAUDFormDescriptor;
    }
    if (isNX)
    {
        U32_StringEntry macroFileName;
    }
    else
    {
        string macroFileName;
    }
    FSkip(-sizeof macroFileName);
    Printf("%s.caud\n", macroFileName);
    //For now
    //struct CookedAudioDataData
    //{
        if (isPack)
        {
            byte CookedAudioDataData[CAUDFormDescriptor.dataSize];
        }
        else
        {
            byte CookedAudioDataData[ContentForm.dataSize];
        }
    //} caud;*/ 
    /*
    struct CAUDData
    {
        if (isNX)
        {
            U32_StringEntry macroFileName;
        }
        else
        {
            string macroFileName;
        }
        uint32 groupNameCount;
        struct GroupNamesData
        {
            for (i = 0; i < groupNameCount; i++)
            {
                struct GroupName
                {
                    string GroupNameStr;
                } gn;
            }
        } gns;
        float unk[2];
        uint32 unk2;
        uint16 unk3[2];
        byte unk4[3];
        float unk5;
        uint32 asamples;
        struct Samples
        {
            for (i = 0; i < asamples; i++)
            {
                struct SampleInfo
                {
                    uint32 infoSize;
                    GUID assetID;
                } smpl;
            }
        } samples;
    } caudData;*/
} CookedAudioSoundEffectChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor UINFFormDescriptor;
    }
    //struct UniverseInfoData
    //{
        GUID UniverseMessageTableGUID;
        GUID SaveSlotMessageTableGUID;
        GUID LoadingAudioGUID;
        for (i = 0; i < 255; i++)
        {
            if (terminateUINF != 1)
            {
                struct AreaInfo
                {
                    ChunkDescriptor Universe_ROOMFormDescriptor;
                    GUID RoomGUID;
                    U32_StringEntry theLocalizedAreaName;
                    byte WorldNum;
                    byte ActNum;
                    DKCTF_LevelType LevelType; //0 means it's a standard level, if 1, it's a boss, setting this to 1 or 0 on one that is a boss doesn't display the level complete UI (confirm), 2 means it's a KONG letter bonus level
                    uint16 PuzzlePieces_ForDisplay; //The amount of Puzzle Pieces to display on the GUI, setting this to more than 9 enforces 9, if the level type is a boss, this is ignored.
                    uint32 unk3[5]<bgcolor=cRed>;
                    DataType checkForEOF<hidden=true>;
                    FSkip(-4);
                    if (checkForEOF == RUDEFormDescriptor)
                    {
                        terminateUINF = 1;
                    }
                } areaInfo;
            }
        }
        terminateUINF = 0;
    //} universeInfo;
} UniverseInfoChunk<bgcolor=cPurple>;

typedef struct
{
    ChunkDescriptor InfoChunkDescriptor;
    //double unk[3];
    struct InfoData
    {
        //float unk[6];
        double unk[3];
    } infoData;
} InfoChunk<bgcolor=cBlue>;

typedef struct
{
    if (isPack)
    {
        FormDescriptor DCLNForm;
        if (DCLNForm.dVer <= 2)
        {
            isLegacyCLSN = 1;
        }
    }
    struct DynamicCollisionData
    {
        InfoChunk INFOChunk;
        VerticesChunk VerticesChunkContent;
        if (isLegacyCLSN == 0)
        {
            MaterialChunk MaterialDclnChunk;
        }
        else
        {
            isLegacyCLSN = 1;
        }
        TrianglesChunk TrianglesChunkContent;
        tree_forDCLN = 1;
        TreeChunk TreeChunkContent;
        tree_forDCLN = 0;
        isLegacyCLSN = 0;
    } dcd;
} DynamicCollisionChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor CLSNForm;
    }
    VerticesChunk VerticesChunkContent;
    if (isCLSN && CLSNForm.fVer != 2 && CLSNForm.dVer != 2)
    {
        MaterialChunk MaterialClsnChunk;
    }
    else
    {
        isLegacyCLSN = 1;
    }
    TrianglesChunk TrianglesChunkContent;
    TreeChunk TreeChunkContent;
    isLegacyCLSN = 0;
} CollisionChunk;

typedef struct
{
    if (isPack)
    {
        FormDescriptor GENPForm;
        //byte theFile[GENPForm.dataSize];
    }
    else
    {
        //byte theFile[ContentForm.dataSize];
    }
    //ChunkDescriptor DescChunkHdr;
    struct GPSData
    {
        ChunkDescriptor DescChunkHdr;
        struct DescBlock
        {
            GenericAssetHeader theHdr<bgcolor=cGreen>;
            byte theGPSFile[DescChunkHdr.dataSize-4]<bgcolor=cRed>;
        } descblk;
    } d;
} GenericParticleSystemChunk;

typedef struct
{
    AssetDirectory AssetDirChunk;
    DataType checkForMETA<hidden=true>;
    FSkip(-4);
    if (checkForMETA == Metadata)
    {
        MetaDataChunk theMeta;
    }
    /*if (hasTXTRMeta)
    {
        MetaDataChunk theMeta;
    }*/
    //Fix for reading dev files
    if (ContentForm.fVer != 1 && ContentForm.dVer != 1 && AssetDirChunk[0].AssetEntriesChunk.theAssetEntry.assetType != Collision && AssetDirChunk[0].AssetEntriesChunk.theAssetEntry.assetType != DynamicCollision)
    {
        NameTagsChunk StringTableChunk;
    }
    /*if (AssetDirChunk.AssetEntriesChunk.assetCount == 1 && AssetDirChunk.AssetEntriesChunk.theAssetEntry.assetType == DynamicCollision)
    {
        isCLSN = 1;
        DynamicCollisionChunk theDCLN;
    }
    if (AssetDirChunk.AssetEntriesChunk.assetCount == 1 && AssetDirChunk.AssetEntriesChunk.theAssetEntry.assetType == Collision)
    {
        CollisionChunk theCSLN;
    }
    if (AssetDirChunk.AssetEntriesChunk.assetCount == 1 && AssetDirChunk.AssetEntriesChunk.theAssetEntry.assetType == LooseData)
    {
        LooseDataChunk theLDTA;
        break; //just stop here
    }*/
    //end
} TableOfContentsContent;

typedef struct
{
    FormDescriptor TOCForm;
    TableOfContentsContent TOCC<bgcolor=cGreen>;
} TableOfContentsChunk;


typedef struct
{
    TableOfContentsChunk TOCChunk;
    struct AssetData
    {
        if (DependencyGroups != 0)
        {
            //struct DependencyGroupChunks
            //{
                for (i2 = 0; i2 < DependencyGroups; i2++)
                {
                    //local string TempName = TOCChunk.TOCC.StringTableChunk.theNameTag.AssetName;
                    DependencyGroupChunk DependencyGroupChunkContent;
                }
            //} dgcs;
        }
        for (i2; i2 < TOCChunk.TOCC.AssetDirChunk.AssetEntriesChunk.assetCount; i2++)
        {
            FormDescriptor TMPCHECK<hidden=true>; //check the header and then go back
            FSkip(-32);
            if (TMPCHECK.contentType == LooseData)
            {
                LooseDataChunk LooseDataChunkContent;
            }
            else if (TMPCHECK.contentType == CookedAudioBusHeiarchy)
            {
                CookedAudioBusHeirachyChunk CookedAudioBusHeirachyChunkContent;
            }
            else if (TMPCHECK.contentType == MessageTable_MessageStudioBinaryText)
            {
                MessageTableChunk MessageTableContent;
            }
            else if (TMPCHECK.contentType == Material)
            {
                MaterialChunk TheMaterialChunk;
            }
            else if (TMPCHECK.contentType == CookedAudioSample)
            {
                CookedAudioSampleChunk CookedAudioSampleContent;
            }
            else if (TMPCHECK.contentType == CookedAudioSoundEffect)
            {
                CookedAudioSoundEffectChunk CookedAudioSoundEffectContent;
            }
            else if (TMPCHECK.contentType == CookedAudioBusHeiarchy)
            {
                CookedAudioBusHeirachyChunk CookedAudioBusHeirachyContent;
            }
            else if (TMPCHECK.contentType == Texture)
            {
                TextureChunk TextureContent;
            }
            else if (TMPCHECK.contentType == UniverseInfo)
            {
                UniverseInfoChunk UniverseInfoContent;
            }
            else if (TMPCHECK.contentType == GenericParticleSystem)
            {
                GenericParticleSystemChunk GenericParticleSystemContent;
            }
            else if (TMPCHECK.contentType == DependencyGroup)
            {
                DependencyGroupChunk DependencyGroupContent;
            }
            else if (TMPCHECK.contentType == Animation)
            {
                AnimationChunk AnimationContent;
            }
            else if (TMPCHECK.contentType == ExtendedTransformAnimation)
            {
                AnimationTransformChunk AnimationTransformContent;
            }
            else if (TMPCHECK.contentType == Skeleton)
            {
                SkeletonChunk SkeletonContent;
            }
            else if (TMPCHECK.contentType == Character)
            {
                CharacterChunk CharacterContent;
            }
            else if (TMPCHECK.contentType == UniverseInfo)
            {
                UniverseInfoChunk UniverseInfoContent;
            }
            else if (TMPCHECK.contentType == FiniteStateMachine)
            {
                FiniteStateMachineChunk FiniteStateMachineContent;
            }
            else if (TMPCHECK.contentType == FlashGFX)
            {
                FlashGFXChunk FlashGFXContent;
            }
            else if (TMPCHECK.contentType == ScaleformGFXLibrary)
            {
                ScaleformGFXLibraryChunk ScaleformGFXLibraryContent;
            }
            else if (TMPCHECK.contentType == Collision)
            {
                isCLSN = 1;
                CollisionChunk CollisionContent;
                isCLSN = 0;
            }
            else if (TMPCHECK.contentType == SwooshParticleSystem)
            {
                SwooshParticleSystemChunk SwooshParticleSystemContent;
            }
            else if (TMPCHECK.contentType == Room)
            {
                RoomChunk RoomContent;
            }
            else if (TMPCHECK.contentType == RuleSetConfig)
            {
                RuleSetConfigChunk RuleSetConfigContent;
            }
            else if (TMPCHECK.contentType == LightProbe)
            {
                LightProbeChunk LightProbeContent;
            }
            else if (TMPCHECK.contentType == DynamicCollision)
            {
                isCLSN = 1;
                DynamicCollisionChunk DynamicCollisionContent;
                isCLSN = 0;
            }
            else if (TMPCHECK.contentType == CookedModel || TMPCHECK.contentType == SkinnedModel || TMPCHECK.contentType == WorldModel)
            {
                if (TMPCHECK.contentType == WorldModel)
                {
                    isWMDL = 1;
                }
                if (TMPCHECK.contentType == SkinnedModel)
                {
                    isSMDL = 1;
                }
                ModelChunk ModelContent;
            }
            else
            {
                Printf("UNKNOWN\n");
            }
        }
        Printf("Hey look at that it worked :)");
    } assetData;

    //TEST! For read MiscData.pak
    //DependencyGroupChunk DependencyGroupContent;
    /*LooseDataChunk LooseDataChunkContent;
    LooseDataChunk LooseDataChunkContent2;
    LooseDataChunk LooseDataChunkContent3;
    LooseDataChunk LooseDataChunkContent4;
    LooseDataChunk LooseDataChunkContent5;
    LooseDataChunk LooseDataChunkContent6;
    LooseDataChunk LooseDataChunkContent7;
    CookedAudioBusHeirachyChunk CookedAudioBusHeirachyChunkContent;
    MessageTableChunk_NMS_MSBT MessageTableContent;
    CookedAudioSampleChunk theCSMP;
    CookedAudioSoundEffectChunk theCAUD;
    MessageTableChunk_NMS_MSBT MessageTableContent2;
    UniverseInfoChunk UniverseInfoContent;
    UniverseInfoChunk UniverseInfoContent2;
    MessageTableChunk_NMS_MSBT MessageTableContent3;
    LooseDataChunk LooseDataChunkContent8;
    LooseDataChunk LooseDataChunkContent9;
    LooseDataChunk LooseDataChunkContent10;
    LooseDataChunk LooseDataChunkContent11;
    LooseDataChunk LooseDataChunkContent12;
    LooseDataChunk LooseDataChunkContent13;
    LooseDataChunk LooseDataChunkContent14;
    LooseDataChunk LooseDataChunkContent15;
    LooseDataChunk LooseDataChunkContent16;
    LooseDataChunk LooseDataChunkContent17;
    LooseDataChunk LooseDataChunkContent18;
    LooseDataChunk LooseDataChunkContent19;*/
    /*if (AssetDirChunk.AssetEntriesChunk.assetCount == 1 && AssetDirChunk.AssetEntriesChunk.theAssetEntry.off != 0)
    {
        NameTagsChunk NameTagsContent;
    }
    //replace if possible
    //if (AssetDirChunk.AssetEntriesChunk.assetCount != 1)
    {
        DataType test<hidden=true>;
        FSkip(-4);
        if (test == RUDEFormDescriptor)
        {
            FormDescriptor UNKForm;
            if (UNKForm.contentType == LooseData)
            {
                LooseDataChunk LooseDataChunkContent;
            }
            if (UNKForm.contentType == DynamicCollision)
            {
                InfoChunk InfoChunkData;
                VerticesChunk VerticesChunkContent;
                TrianglesChunk TrianglesChunkContent;
                TreeChunk TreeChunkContent;
            }
            if (UNKForm.contentType == Collision)
            {
                VerticesChunk VerticesChunkContent;
                TrianglesChunk TrianglesChunkContent;
                TreeChunk TreeChunkContent;
            }
        }
        if (test == STRG)
        {
            NameTagsChunk NameTagsContent;
            FormDescriptor UNKForm2;
            if (UNKForm2.contentType == LooseData)
            {
                LooseDataChunk LooseDataChunkContent;
            }
            if (UNKForm2.contentType == DependencyGroup)
            {
                DependencyGroupChunk DependencyGroupContent;
            }
        }
        if (test == Metadata)
        {
            MetaDataChunk MetaDataContent;
            NameTagsChunk NameTagsContent;
        }
    }*/
    //end
} PackageChunk;

typedef struct
{
    ChunkDescriptor RFLODesc;
    byte theRFLO[RFLODesc.dataSize];
    /*struct RenderFlowContent
    {
        /*uint32 unk;
    uint32 stringCount;
    for (i = 0; i < stringCount; i++)
    {
        struct FlowString
        {
            uint16 unk3;
            uint16 index;
            if (i == 0)
            {
                string theSceneStr;
                local string theStr = "";
            }
            else
            {
                string theStr;
            }
            if (theStr == "Color" || theStr == "Depth" || theStr == "GBuffer" || theStr == "Diffuse" || theStr == "Specular")
            {
                int32 width;
                int32 height;
                byte unk1;
                byte unk2;
                byte unk4;
                byte unk5;
                byte unk6;
            }
            if (theStr == "ForwardRenderBlock")
            {
                //int16 unk;
            }
        } fs;
    }
    } theRFLOContent;*/
} RenderFlowChunk; //WIP