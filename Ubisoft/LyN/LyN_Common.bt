//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//https://forum.zoneofgames.ru/topic/23644-from-dust/?page=6
//https://github.com/RetingencyPlan/le_quickbms_script_compendium/blob/master/sally_bf.bms
//https://autoit-script.ru/threads/pomogite-rasparsit-tekstovyj-fajl.6525/

//NOTE: This documentation and all templates here is based off content extracted with sally_bf.bms as that one is the most efficient LyN extraction tool. This may be different if you use a different tool.

//Content here referencing hexes is byteswapped

//TERMINOLOGY:
/*
ma*: Array
mi: Int
msb: u32 bool
masz/msaz: char array

Read/binarizing flags:
    1: Not in binned data
    2: In all
    3: Not in retail game bin
*/

#include "../../LHR/Common.bt"

local uint DEBUG_PRINT <hidden=true> = 0;
local uint loadedFromBin <hidden=true> = 0;
local uint isNewLyN <hidden=true> = 0;

typedef enum <uint32>
{
   LyN_ScriptVarType_Text = 65544,
   LyN_ScriptVarType_Dialog = 131080,
   LyN_ScriptVarType_Int32 = 1310720,
   LyN_ScriptVarType_F32 = 1376256,
   LyN_ScriptVarType_Vector = 1441792,
   LyN_ScriptVarType_Modifier = 1703936
} LyN_ScriptVarType;

typedef enum <uint16>
{
   LyN_ModifierType_ScriptInstance = 0,
   LyN_ModifierType_DesignStruct,
   LyN_ModifierType_Message,
   LyN_ModifierType_Visual,
   LyN_ModifierType_Group,
   LyN_ModifierType_Network,
   LyN_ModifierType_Skeleton,
   LyN_ModifierType_ObjectTable,
   LyN_ModifierType_TextList,
   LyN_ModifierType_Light,
   LyN_ModifierType_Particle,
   LyN_ModifierType_Flexi,
   LyN_ModifierType_Interkinetic3Points,
   LyN_ModifierType_AnimEvents,
   LyN_ModifierType_Animation,
   LyN_ModifierType_Actions,
   LyN_ModifierType_LookAt,
   //Dummy?
   LyN_ModifierType_EffectMiscGfx = 18,
   LyN_ModifierType_AnimEventZoneDefinition,
   LyN_ModifierType_CollisionMapBounds,
   LyN_ModifierType_DynamicPhysics,
   LyN_ModifierType_SoundBank,
   LyN_ModifierType_SFXArea,
   LyN_ModifierType_ViewPoint,
   LyN_ModifierType_NOX,
   LyN_ModifierType_Constraint,
   LyN_ModifierType_AnimLipSync,
   LyN_ModifierType_GlobalGizmo,
   LyN_ModifierType_AfterGFX,
   
   LyN_ModifierType_LocalGizmo = 31,
   
   LyN_ModifierType_VegationGFX = 33,
   
   LyN_ModifierType_OccluderGFX = 35,
   LyN_ModifierType_GlobalZoneGFX,
   LyN_ModifierType_SavePosition,
   LyN_ModifierType_Water,
   LyN_ModifierType_TrailGenerator,
   LyN_ModifierType_RenderParameters,
   LyN_ModifierType_SoundLinker,
   LyN_ModifierType_VisualFarm,
   
   LyN_ModifierType_Grid = 44,
   
   LyN_ModifierType_BackgroundVideo = 46,
   
   LyN_ModifierType_Magma = 48,
   LyN_ModifierType_SharpShadow,
   
   LyN_ModifierType_GraphicBV = 53,
   
   LyN_ModifierType_Fire = 56,
   LyN_ModifierType_SoundPrefetch,
   
   LyN_ModifierType_Camera = 61,
   LyN_ModifierType_Rope,
   LyN_ModifierType_InstanceList,
   
   LyN_ModifierType_LocalRenderParameters = 65,
   LyN_ModifierType_PFBInstanceParameters,
   LyN_ModifierType_WiresGenerator,
   LyN_ModifierType_MotionPhysics,
   
   LyN_ModifierType_OutlineGeometryGFX = 71,
   
   LyN_ModifierType_FluidGFX = 73,
   
   LyN_ModifierType_FakeLight = 75,
   LyN_ModifierType_MIDIPartitionsBank,
   LyN_ModifierType_JDLiveMoveBank,
   LyN_ModifierType_Localization,
   LyN_ModifierType_JDMoveSpace,
   LyN_ModifierType_PartitionBank,
} LyN_ModifierType;

typedef int32 LyN_HandleKey; //This is officially u32 but since FF means nothing I'd make it s32

typedef struct LyN_Int64 //Officially I64 but really it's two uints.
{
    uint32 high;
    uint32 low;
};

typedef struct LyN_Reference //For MDL, 3 refs: VAR, FCT, EFC
{
    LyN_HandleKey handle;
    uint32 privateFlags;
    uint32 userFlags;
};

typedef struct LyN_NestedInt64
{
    LyN_Int64 nestedI64;
    quad quadVal;
};

typedef struct LyN_AuxSendDefine
{
    uint32 ver; //2
    uint32 flags;
    int32 level;
    LyN_HandleKey ref;
    if (ver < 2)
        uint32 unk;
};

typedef struct LyN_SoundInsert
{
    uint16 ver;
    uint16 type;
    uint32 flag;
};

typedef enum <uint32>
{
    LyN_TextureFormat_Targa,
    LyN_TextureFormat_Targa32Bit,
    LyN_TextureFormat_DXT //DXT1 on 4 JD Wii U
} LyN_TextureFormat;

typedef enum <ubyte>
{
    LyN_TexPixelFormat_ARGB8888,
    LyN_TexPixelFormat_R16F,
    LyN_TexPixelFormat_RG16F,
    LyN_TexPixelFormat_ABGR16F,
    LyN_TexPixelFormat_R32F,
    LyN_TexPixelFormat_GR32F,
    LyN_TexPixelFormat_ABGR32F,
    LyN_TexPixelFormat_D16,
    LyN_TexPixelFormat_D24S8,
    LyN_TexPixelFormat_DXT1, //CMPR on Wii
    LyN_TexPixelFormat_DXT3,
    LyN_TexPixelFormat_DXT5,
    LyN_TexPixelFormat_D16Tex,
    LyN_TexPixelFormat_D24S8Tex,
    LyN_TexPixelFormat_RGB565,
    LyN_TexPixelFormat_A2RGB10,
    LyN_TexPixelFormat_XRGB8888,
    LyN_TexPixelFormat_A8, //On Wii, some Wii swizzled 8 channel format
    LyN_TexPixelFormat_L8,
    LyN_TexPixelFormat_AL88,
    LyN_TexPixelFormat_ARGB4444,
    LyN_TexPixelFormat_AL44,
    LyN_TexPixelFormat_NONE,
    LyN_TexPixelFormat_RawDepth, //No clue, 8 channel
    LyN_TexPixelFormat_ABGR16,
    LyN_TexPixelFormat_L16,
    LyN_TexPixelFormat_GR16,
    LyN_TexPixelFormat_ACPR, //No clue, distance-based DXT1?
} LyN_TexPixelFormat;

typedef struct LyN_LoadingReference
{
};

typedef struct LyN_BoundingVolume
{
    uint32 type;
    uint32 ver;
    uint32 flags;
};

typedef struct LyN_BoundingVolumeBox //also AABox
{
    LyN_BoundingVolume bv;
    uint32 ver;
    Vector3_F32 ctr;
    Vector3_F32 halfVec;
};

typedef struct LyN_BoundingVolumeInfinite
{
    LyN_BoundingVolume bv;
    uint32 ver;
};

typedef struct LyN_BoundingVolumeSphere
{
    LyN_BoundingVolume bv;
    uint32 ver;
    Vector3_F32 ctr;
    float rad;
};

typedef struct LyN_BoundingVolumePyramid
{
    LyN_BoundingVolume bv;
    uint32 ver; //2
    if (ver >= 2)
    {
        float len;
        Vector2_F32 halfVec;
    }
    else
    {
        Vector3_F32 ctr;
        Vector3_F32 dir;
        Vector3_F32 top;
        Vector3_F32 btm;
        Vector3_F32 halfVec;
        float unk;
    }
};

typedef struct LyN_Octree
{
    Vector3_F32 min;
    Vector3_F32 max;
    struct
    {
        ubyte relMin[3];
        ubyte relMax[3];
        uint16 elems;
        struct
        {
            uint16 idx;
            uint16 tris;
            uint16 tri[tris];
        } Element[elems];
    } Node[nodes]<optimize=false>;
};

typedef struct LyN_BinHeader //Appears on FF (Map) and FD (SFX) - is that right?
{
    LyN_HandleKey file; //handle?
    uint32 chunkSz;
};

typedef struct LyN_NewArchivedFileHeader
{
    uint32 fileSize[2]; //Why twice? uhhhh
    uint32 refContainerSz;
    uint32 unk; //Ver?
    uint32 unk2;
    uint32 contentType;
    uint32 unk3[2];
};

typedef struct LyN_ThreeDShadowTexture
{
    uint32 ver; //0x0A: RGH
    Vector2_F32 sizeFactor;
    float zAttFactor;
    float zSzFactor;
    float zStartFactor;
    if (ver >= 5) float opacFactor;
    uint32 shadowTextureUsedHandle;
    Vector3_F32 unk;
    if (ver < 2) uint16 unk2;
    uint32 flags;
    if (ver == 3)
    {
        uint32 unk3;
    }
    uint32 projMeth;
    uint32 shadowColor;
    ubyte renderGroup;
};

typedef struct LyN_Stock
{
    uint32 magic; //0xC0DEC0DE
    if (magic == 0xC0DEC0DE)
    {
        uint32 ver;
        uint32 firstInt;
    }
    uint32 unk[4]; //Read as u32 despite being i32
    float unk2[5];
    LyN_HandleKey obj[5];
    if (magic == 0xC0DEC0DE) LyN_HandleKey modifier[5];
    Vector3_F32 vec[5];
};

typedef struct LyN_ScriptingSignal
{
    LyN_HandleKey functionList;
    char name[64];
    LyN_HandleKey object;
    uint32 modifierRank;
};

typedef struct LyN_ScriptingTrigger
{
    LyN_ScriptingSignal scriptingSignal;
    LyN_Stock stock;
};

typedef struct LyN_MathBox
{
    Vector3_F32 min;
    Vector3_F32 max;
    Vector3_F32 ctr;
    if (!loadedFromBin) uint32 flags;
};

typedef struct LyN_ParticleConstraint
{
    uint32 type;
    float f32Params[16];
    //uint32 u32Params[16]; //Unused
};

typedef struct LyN_Modifier
{
    uint32 flags;
    uint16 ver;
    uint16 typeID;
    if (typeID == 0xFFFF)
    {
        LyN_ModifierType type;
        uint16 id;
        uint16 modifierVer;
        if (modifierVer > 1 && !loadedFromBin)
        {
            int16 pfbOMods;
            //LyN_HandleKey prebOMod[pfbOMods]; //?
            uint32 pfbOModKeys;
            //LyN_HandleKey prebOMod[pfbOModKeys];
        }
    }
};

typedef struct LyN_ScriptVariableContainer //VERY WIP
{
    uint32 id; //0xC0DEC0DE OR 0xC0DEC0DF (Not in JD4) OR 0xC0DEC0EF (Not in RLand)
    
    //This is the worst format.
    //uint32 ver; //0 in TMNT?
    //uint32 count;
    
    if (id == 0xC0DEC0EF) //The standard one, used in EFG, EFC, EFL (Embedded), FFBin and MDL
    {
        uint32 ver;
        uint32 count;
        uint32 firstMdlOff;
        uint32 firstInitOff;
        uint32 firstCurOff;
    }
    else if (id == 0xC0DEC0DE) //EFC (RLand) and embedded in FFBin
    {
        local uint ver = 0;
        uint32 firstMdl;
        uint32 firstInit;
        uint32 firstCur;
    }
    else if (id == 0xC0DEC0DF) //MDL or nested in EFC, EFG and EFL in RLand, TMNT EFL
    {
        uint32 firstPosInit;
        uint32 count;
        uint32 ver; //2 in TMNT
    }
    struct
    {
        uint32 idx;
        LyN_ScriptVarType type;
        if (ver > 1)
        {
            uint32 dtype;
            if (!loadedFromBin) uint32 dsz; //TODO check this, DOE flag 1, not present in BINned scripts
        }
        uint32 cpos;
        uint32 sz;
        uint32 szd[3];
        uint32 strLen[4];
        uint16 flags;
        ubyte flagByte;
        ubyte saveStrIdx;
        if (ver > 2) ubyte validIdx;
        uint32 fields;
        char name[strLen[0]]; if (DEBUG_PRINT) Printf("[%i]: Index: %i, Type: %s, Name: %s, Size: %i, Fields: %i\n", i, idx, EnumToString(type), name, sz, fields);
        if (!loadedFromBin && strLen[1]) char name2[strLen[1]]; //Flag 1, not present in BINned scripts
        if (!loadedFromBin && strLen[2]) char sep[strLen[2]]; //Flag 1, not present in BINned scripts
        if (!loadedFromBin && strLen[3]) char comment[strLen[3]]; //Flag 1, not present in BINned scripts
        if (type == 3080192 || (ver > 1 && type == 5046272))
        {
            if (ReadUInt() == 3235823855 || ReadUInt() == 3235823839)
                struct LyN_ScriptVariableContainer nestedVarContainer;
            else
                uint32 pad; //0xABCD6666
        }
        i++;
    } Variable[count]<optimize=false>;
    i = 0;
    uint32 mdlSz;
    uint32 initSz;
    if (ver > 3)
    {
        uint32 initInstSz;
        uint32 initInstCurSz;
    }
    else
    {
        local uint32 initInstSz = initSz;
        local uint32 initInstCurSz = initSz;
    }
    if (mdlSz && initSz) //todo parse of this data, engine officially checks for either of these but both work so :shrug:
    {
        byte mdl[mdlSz];
    }
};

typedef struct LyN_Matrix44
{
    Vector3_F32 I;
    float SX;
    Vector3_F32 J;
    float SY;
    Vector3_F32 K;
    float SZ;
    Vector3_F32 T;
    float W;
};

typedef struct LyN_TRMatrix
{
    LyN_Matrix44 TR;
    LyN_Matrix44 R;
    Vector3_F32 T;
    uint32 f;
};

typedef struct LyN_MathCurve //CRV
{
    uint32 ver; //4 in all
    Vector2_F32 min;
    Vector2_F32 max;
    uint32 samples;
    if (ver > 2)
        uint32 type;
    if (ver && !loadedFromBin)
        Vector2_F32 grid;
    float sample[samples];
    local uint colors = 0;
    if (ver > 3) RGBA_UByte color[(type & 2) != 0 ? samples/5 : 0];
};

typedef struct LyN_MathSphere
{
    float rad;
    Vector3_F32 ctr;
    if (!loadedFromBin) uint32 flags; //TODO check this
};

typedef struct LyN_MathConvexBox
{
    Vector3_F32 pt[8];
    uint32 flags;
};

typedef struct LyN_MathCylinder
{
    float rad;
    float height;
    Vector3_F32 ctr;
    uint32 flags;
};

typedef struct LyN_CullingRenderParam
{
    uint32 ver; //5 in JD4
    if (ver >= 3) float camFarPln;
    float camNearPln;
    float audoFarCullDistRef;
    float cullDist;
    ubyte spgCacheLod;
    ubyte spgCutLod;
    ubyte pad[2];
    float spgCutLodDist;
    float spgFarLodDist;
    if (ver >= 2)
    {
        float shadowFarMin;
        float shadowFarMax;
    }
    if (ver == 4)
    {
        float unk[2];
    }
};

typedef struct LyN_FogRenderParam
{
    uint32 id; //1 in JD4 and RGH
    uint32 flags;
    uint32 clr;
    float start;
    float end;
    float density;
    float minFog;
    float maxFog;
    float skySlpMin;
    float skySlpMax;
    uint32 skyClrNear;
    uint32 skyClrFar;
    uint32 skyClrUp;
    uint32 skySunClr;
    float skySunExpo;
    float skySunInt;
};

typedef struct LyN_WiiGlowRenderParam
{
    uint32 ver; //2 in JD4 and RGH
    U32_Bool enable;
    if (ver >= 2) U32_Bool instantFactor;
    float blur;
    float glow;
};

typedef struct LyN_UVModifier_TileAnimation
{
    uint32 ver;
    uint16 cols;
    uint16 rows;
    float speed;
};

typedef struct LyN_UVModifier_Translation
{
    uint32 ver;
    float du;
    float dv;
    uint32 flags;
};

typedef struct LyN_UVModifier_Scale
{
    uint32 ver;
    float su;
    float sv;
    Vector2_F32 pivot;
};

typedef struct LyN_UVModifier
{
    char name[64];
    uint32 dmy; //1
    U32_Bool enable; //1
    switch (name)
    {
        case "K3D_UVModifier_TileAnimation": LyN_UVModifier_TileAnimation UVModifier_TileAnimation; break;
        case "K3D_UVModifier_Translation": LyN_UVModifier_Translation UVModifier_Translation; break;
        case "K3D_UVModifier_Scale": LyN_UVModifier_Scale UVModifier_Scale; break;
    }
};

typedef struct LyN_UVParamContainer
{
    uint32 ver; //10 in JD4
    ubyte src;
    ubyte pln;
    ubyte plg;
    ubyte mods;
    LyN_UVModifier UVModifier[mods]<optimize=false>;
    if (ver >= 7)
    {
        LyN_HandleKey srcIndirTex;
        uint32 indirUVSrc;
        if (ver > 9) uint32 indirUVAdd;
        Vector2_F32 displScl;
        if (ver >= 8) uint32 flags;
        if (ver > 9) U32_Bool nrm;
    }
};

typedef struct LyN_WiiRefraction
{
    uint32 ver; //7
    LyN_HandleKey srcFile;
    U32_Bool use;
    if (ver >= 3) U32_Bool afterTrans;
    if (ver >= 6) U32_Bool once;
    Vector4_F32 refraction;
    LyN_UVParamContainer uvParams;
    U32_Bool constantAlpha;
    if (ver >= 4)
    {
        uint32 alphaTestFct;
        float alphaTestVal;
        if (ver >= 5) U32_Bool blueAlpha;
    }
    if (ver >= 7)
    {
        U32_Bool attenuationDepth;
        float attenuationDepthStart;
        float attenuationDepthEnd;
    }
};

typedef struct LyN_WiiBasicLevelDescription
{
    uint32 flags;
    LyN_HandleKey texSrcFile;
    LyN_HandleKey alphaTexSrcFile;
    RGBA_UByte color;
    LyN_UVParamContainer UVParamContainer;
    ubyte blend;
    ubyte alphaFct;
    ubyte alphaThr;
};

typedef struct LyN_UVDefine
{
    float u;
    float v;
};

typedef struct LyN_WiiMultiTexture
{
    uint32 ver; //11, 9 in RGHPC
    uint32 levels;
    uint32 rMask;
    uint32 flags;
    float zBias;
    struct
    {
        LyN_WiiBasicLevelDescription basicLevelDesc;
        if (ver >= 10) float unlit;
    } Level[levels]<optimize=true>;
};

typedef struct LyN_WiiSimpleTexture
{
    uint32 ver; //3
    LyN_WiiMultiTexture mTex;
};

typedef struct LyN_WiiGlow
{
    uint32 ver; //4
    uint32 template;
    LyN_WiiMultiTexture mTex;
};

typedef struct LyN_SimpleSpriteMaterial
{
    uint32 ver; //7
    LyN_HandleKey srcFile;
    U32_Bool diffuse;
    RGBA_F32 difffuseColor;
    U32_Bool diffuseColormult;
    LyN_UVParamContainer uvParams;
    int32 blend;
    LyN_HandleKey sepAlphaSrcFile;
    if (ver > 6) U32_Bool sepAlpha;
};

typedef struct LyN_CartoonRenderParam
{
    uint32 ver; //2 in JD4 and RGH
    uint32 levels;
    RGBA_UByte clr[6]<optimize=false>;
    float lim[5];
    if (ver > 1) float lightOff;
};

typedef struct LyN_WiiRenderParam
{
    uint32 ver; //1 in JD4 and RGH
    if (ver <= 1) uint32 multiplier;
};

typedef struct LyN_AORenderParam
{
    uint32 ver; //3 in JD4
    RGBA_UByte clr;
    float factor;
    if (ver >= 2)
    {
        uint32 rays;
        float rayLength;
        float angleFct;
    }
    if (ver >= 3) uint32 flags;
};

typedef struct LyN_FakeLightingRenderParam
{
    uint32 id; //1 in JD4 and prob RGH
    U32_Bool enabled;
    uint32 value;
};

typedef struct LyN_GuideList
{
    uint32 ver; //1
    uint32 entries;
    struct
    {
        uint32 points;
        if (!loadedFromBin)
        {
            Vector3_F32 point[points];
            RGBA_UByte color;
            uint32 flags;
            float width;
            U32_Bool closed;
        }
    } Guide[entries];
};

typedef struct LyN_RenderParam
{
    uint32 ver; //9 in RGH. 12 in JD4
    if (ver)
    {
        ubyte flags;
        ubyte prio;
        ubyte viewports;
        ubyte viewpoints;
        RGBA_UByte colorBack;
        RGBA_UByte colorAmb[2]<optimize=false>;
        if (ver > 5 && ver != 7 && ver != 6) RGBA_UByte colorSHV;
        if (ver > 5 && ver != 6)
        {
            ubyte lightMaskNandLGCY;
            ubyte lightMaskOrLGCY;
        }
        if (ver >= 9) float lightCoef[ver >= 12 ? 16 : 8]; //16 in JD4, 8 in RGH? Don't remember
        if (ver >= 5)
        {
            if (ReadUInt() >= 5) LyN_CullingRenderParam CullParam;
            LyN_FogRenderParam FogParam;
            LyN_WiiGlowRenderParam WiiGlowParam;
            LyN_CartoonRenderParam CartoonParam;
            LyN_WiiRenderParam WiiRenderParam;
            //IN RGH THESE AREN'T HERE
            if (ver >= 10)
            {
                LyN_AORenderParam AORenderParam;
                LyN_FakeLightingRenderParam FakeLightingRenderParam;
            }
        }
        //if (ver >= 5) CullParam;
    }
    else //Legacy params
    {
        uint32 unk[8];
        uint32 lgcyBaseVer;
        if (lgcyVer >= 2)
        {
            uint32 unk2[2];
            if (lgcyBaseVer >= 3) uint32 unk3;
            if (lgcyBaseVer >= 6) uint32 unk4;
            if (lgcyBaseVer >= 7) uint32 unk5;
            if (lgcyBaseVer >= 5) uint32 unk6;
            if (lgcyBaseVer >= 12) uint32 unk7;
            if (lgcyBaseVer >= 15) uint32 unk8;
            if (lgcyBaseVer >= 10)
            {
                uint32 unk9[7];
                if (lgcyBaseVer >= 11) uint32 unk10[3];
                uint32 unk11[3];
            }
        }
        if (lgcyBaseVer >= 4)
        {
            uint32 magic;
            if (magic == 0xC0DEC0DE)
            {
                uint32 lgcyVer;
                uint32 unk12;
            }
            else local uint lgcyVer = 0;
            if (lgcyVer < 2) uint32 unk13;
            if (lgcyVer)
            {
                ubyte unk14[2];
                uint32 unk15[2];
                if (lgcyVer >= 3) uint32 unk16;
            } 
        }
        if (lgcyBaseVer >= 8)
        {
            if (lgcyBaseVer >= 9) uint32 unk17;
            uint32 unk18[6];
            uint32 unk19[9];
        }
        if (lgcyBaseVer >= 13) uint32 unk20[2];
        if (lgcyBaseVer >= 14) uint32 unk21[2];
    }
};


/*
Notes (RGH + JD4):

Channel: Wii Channel, wog loading
RLab: Not defined as Wii Channel, wog loading
PC: Not defined as Wii Channel, wog loading, FF003C8 mentions B4141025 as the preload wog from default.cfg

GrpRef: Refs to libs (FCG+EFG)
    MathLib
    DebugLib
    DynamicLib
    DynamicLib
    EventLib
    GameLib
    MappingLib
    CommonLib
    TriggerLib
    ModifierLib
    GraphicsLib
    ActionsLib
    BunniesLib
    EventLibBunnies
    TriggerBunnyLib

Reference:
    0x00: BigFileRef (in WOG, 25100DD8 (PC) = _basic_ForMaps_GPP.wog, in GRP, 3 u32s, the last two being padding, in)
    
    Mdl Ref:

    JD4:
        SoundMixer: Curve reference, unknown flags.
        Song Wog: Base WOG reference, min WOG reference, editor WOG references
        Preview Wog: Unknown reference, unknown flags.
        MapsToBinarize Wog: _PLATFORM.wog references[unknown flags]
        BackgroundList Wog: Unknown reference [unknown flags], preview WOG references
        LobbyList Wog: Unknown reference [unknown flags], lobby WOG references[unknown flags]
        LevelDescriptorList Wog: Unknown reference [unknown flags]
        _PLATFORM Wog: Base _PLATFORM WOG reference [unknown flags], unknown [unknown flags], widgets _PLATFORM wog reference
        AudioPreview_List Wog: Unknown reference [unknown flags], Unknown reference [unknown flags]
        AudioPreview_List_PLATFORM Wog: Unknown reference [unknown flags]
        Preview_List Wog: Unknown reference [unknown flags]
        ProfileModule Wog: Unknown reference [unknown flags], Unknown reference [unknown flags]
        Shop _PLATFORM wog: Common _PLATFORM reference [unknown flags], Unknown reference [unknown flags]
        Preview *_SONG wog: Unknown reference [unknown flags]
        UI _PLATFORM wog: Unknown reference [unknown flags]
        Common _PLATFORM wog: _Common_PLATFORM wog reference [unknown flags], CommonLevel_PLATFORM wog reference [unknown flags], HUD_PLATFORM wog reference [unknown flags], AudioPreview_List_Common wog reference [unknown flags], AudioPreview_List_SSC wog reference [unknown flags], AudioPreview_List_PLATFORM wog reference [unknown flags], Preview_List_Common wog reference [unknown flags], Preview_List_SSC wog reference [unknown flags], Preview_List_PLATFORM wog reference [unknown flags]
        LevelInterface_PLATFORM wog: Unknown reference [unknown flags]
        PAGESET_Main_PLATFORM wog: Unknown references [unknown flags]
        Common_Level_* wog: Unknown reference [unknown flags]
        UI_P_*_PLATFORM wog: Unknown reference [unknown flags]
        Preview_Transition*_Common wog: References to preview WOGS [unknown flags]
        HUD_* wog: Unknown reference [unknown flags], UI_JD4_HUD_*_Common wog reference [unknown flags]
        UI_JD4_HUD_*_Common wog: Unknown references [unknown flags]
        UI_JD4_HUD_*_PLATFORM wog: Reference to UI_JD4_HUD_*_Common wog [unknown flags]
        Song_GAMEPLAY_PLATFORM wog: Unknown references.
        6902ee*.bin: Text.
        fc*.bin: Text container references.
        fd*.bin: Mic ref, SceneMix

Bin:
    16/A0: Text, may contain RIFF headers and other stuff idk
    1D****LL/93: Text (A: EN, B: FR, C: SP D: EN, E: ES, F: SP, 0: EN, 3: EN, 9 FR), on PC can contain OGG files, referenced in FC files
    F1: Text
    FB: MAGMA [Universal serialization lib, mentions texture names]
    FC: These usually contain 76 bytes of handles? Text references?
        uint32 refs;
        struct
        {
            uint32 hKey; //a0 ref
            uint32 unk[2];
        } Ref[refs];
    FD (BIN): All tend to reference the scenemixer and microphone, on PC OGG files
        RefTable (U32, 12 byte refs):
    FE: Texture container
    FF: Map (can reference text and FE+FD files[?], worlds) [?] Can be referenced in 93, FF and FD?
        uint32 handlekey;
        uint32 fSize;
        
        Seems each file has a flag which counts towards fsz, Idk how this works. Tested ON RGH!
        15/283/437/1865/1938: LyN_ScriptInstance_INS
        30: LyN_Magma_MGM
        32: LyN_AnimationAction_ACI
        36/74: LyN_SoundBank_SNK_SKM or LyN_ObjectTable
        92: LyN_Skeleton
        157: LyN_Visual
        286: LyN_Object_OBJ
        294: ?
        772: LyN_World
        454/1452/9566: RGH_MagmaFile_MGF
        564: LyN_ScriptModel_MDL

    EFC: Track
    EFL: Track
    EFG: Global proclist, ends with this handlekey.
    
    NewLyN Formats:
        AI: AI
        FEU: Fire UI (SWF), references are .tex files.
        FFD: Fire Font Data (SWF)
        GEO: ?
        LIG: Light
        MAT: Material
        MTA: Metal
*/