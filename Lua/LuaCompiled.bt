//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//http://domoticx.com/lua-bytecode-ontcijferen-luac/
//https://www.twblogs.net/a/5b8c24e42b7177188330c536/?lang=zh-cn
//http://files.catwell.info/misc/mirror/lua-5.2-bytecode-vm-dirk-laurie/lua52vm.html
//https://github.com/viruscamp/luadec/blob/master/ChunkSpy/
//https://web.archive.org/web/20201126175122/http://luaforge.net/projects/chunkspy/

//ONLY SUPPORTS NAMELY 5.0-5.1 NOT 5.2, MAY SUPPORT 4.0

#include "../LHR/Common.bt"

local string luaBoolStr <hidden=true> = "";
local uint DEBUG_PRINT <hidden=true> = 0; //Use this to print debug info
local uint isSubFunc <hidden=true> = 0; //TEMP HACKS
local uint isLocal <hidden=true> = 0; //TEMP HACKS

typedef enum <byte>
{
    PLV_Null,
    PLV_Bool,
    PLV_Decimal = 3,
    PLV_Number,
    PLV_String,
} PopCap_Custom_LuaVarType;

typedef enum <byte>
{
    LV_Bool = 1,
    LV_Decimal = 3,
    LV_String,
    LV_Number,
} LuaVarType;

typedef enum <uint32>
{
    LOP_MOVE,
    LOP_LOADK,
    LOP_LOADBOOL,
    LOP_SETGLOBAL = 0x000007,
    LOP_RETURN = 0x0000801B,
} LuaOpCode;

typedef enum <uint32>
{
    PLOP_LOADBOOL = 0x000002,
    PLOP_LOADNIL,
    PLOP_GETGLOBAL = 0x000005,
    PLOP_SETGLOBAL = 0x000007,
    PLOP_NEWTABLE = 0x00000A,
    PLOP_DEFGLOBAL = 0x000027,
    PLOP_CLOSURE = 0x000030,
    PLOP_RETURN = 0x00801D,
} PopCap_Custom_LuaOpCode;

typedef enum <byte>
{
    LuaVersion_40 = 0x40,
    LuaVersion_50 = 0x50,
    LuaVersion_51,
    LuaVersion_52,
    LuaVersion_53,
    PopCap_Custom_Lua5 = 0x56,
} LuaVersion;

typedef struct LuaString
{
    uint32 stringSize;
    if (hdr.endian == 2)
    {
        wchar_t lstring[stringSize];
    }
    else
    {
        char lstring[stringSize];
    }
    if (DEBUG_PRINT == 1 && stringSize > 0)
    {
        Printf("%s\n", lstring);
    }
};

typedef struct LuaVar
{
    if (hdr.ver == PopCap_Custom_Lua5)
    {
        PopCap_Custom_LuaVarType luaVarType;
        if (luaVarType == PLV_Number)
        {
            uint32 luaI32;
            if (DEBUG_PRINT == 1)
            {
                Printf("%i\n", luaI32);
            }
        }
        else if (luaVarType == PLV_String)
        {
            /*if (isLocal == 1)
            {
                FSkip(-1);
            }*/
            LuaString luaStr;
        }
        else if (luaVarType == PLV_Decimal)
        {
            if (hdr.lua_number_sz == 6)
            {
                double luaDec;
                if (DEBUG_PRINT == 1)
                {
                    Printf("%lf\n", luaDec);
                }
            }
            else
            {
                float luaDec;
                if (DEBUG_PRINT == 1)
                {
                    Printf("%f\n", luaDec);
                }
            }
        }
        else if (luaVarType == PLV_Bool)
        {
            byte luaBool;
            if (DEBUG_PRINT == 1)
            {
                if (luaBool == 0x01)
                {
                    luaBoolStr = "true";
                }
                else if (luaBool == 0x01)
                {
                    luaBoolStr = "false";
                }
                Printf("%s\n", luaBoolStr);
            }
        }
    }
    else
    {
        LuaVarType luaVarType;
        if (luaVarType == LV_Number)
        {
            uint32 luaI32; //Will change later
            if (DEBUG_PRINT == 1)
            {
                Printf("%i\n", luaI32);
            }
        }
        else if (luaVarType == LV_String)
        {
            LuaString luaStr;
        }
        else if (luaVarType == LV_Decimal)
        {
            if (hdr.lua_number_sz == 8)
            {
                double luaDec;
                if (DEBUG_PRINT == 1)
                {
                    Printf("%f\n", luaDec);
                }
            }
            else
            {
                float luaDec;
                if (DEBUG_PRINT == 1)
                {
                    Printf("%f\n", luaDec);
                }
            }
        }
        else if (luaVarType == LV_Bool)
        {
            byte luaBool;
            if (DEBUG_PRINT == 1)
            {
                if (luaBool == 0x01)
                {
                    luaBoolStr = "true";
                }
                else
                {
                    luaBoolStr = "false";
                }
                Printf("%s\n", luaBoolStr);
            }
        }
    }
};

typedef struct LuaFunction
{
    if (isSubFunc == 1)
    {
        uint32 unk;
        if (unk == 1 || unk == 2) //Temp hacks
        {
            FSkip(4);
        }
        else if (unk >= 199) //Temp hacks
        {
            FSkip(-4);
            struct Code2
            {
                uint32 codesz2;
                if (hdr.ver == PopCap_Custom_Lua5)
                {
                    PopCap_Custom_LuaOpCode plop2[codesz2];
                }
                else
                {
                    LuaOpCode lop2[codesz2];
                }
            } code2<optimize=false>;
            break;
        }
    }
    uint32 linedef;
    if (hdr.ver > 'P')
    {
        uint32 endline;
    }
    byte nupvs;
    byte numparams;
    byte vararg;
    byte maxStackSz;
    struct Lines
    {
        uint32 lines;
        uint32 line[lines];
    } lines;
    struct Locals
    {
        uint32 locals;
        if (locals > 0)
        {
            struct LocalEntry
            {
                isLocal = 1;
                if (hdr.ver > 'P' && hdr.ver != 'V')
                {
                    LuaVar lv;
                }
                else
                {
                    LuaString locString;
                    uint32 startPc;
                    uint32 endPc;
                }
            } le[locals]<optimize=false>;
        }
    } locals;
    isLocal = 0;
    struct UpValues
    {
        uint32 upVVars;
        if (upVVars > 0)
        {
            LuaString upVString[upVVars]<optimize=false>;
        }
    } upvalue;
    if (hdr.ver <= 'P' || hdr.ver == 'V')
    {
        struct Constants
        {
            uint32 constants;
            if (constants > 0)
            {
                LuaVar lcv[constants]<optimize=false>;
            }
        } constants;
        /*
        struct SubFunctions
        {
            uint32 subfunctions;
            struct SubFunction
            {
                LuaString srcName;
            } subfunction[subfunctions]<optimize=false>;
        } subfunctions;*/
        if (ReadByte() != 0)
        {
            break; //There has to be a better way
        }
        else
        {
            uint32 zeroSubFuncs;
        }
    }
    struct Code
    {
        uint32 codesz;
        if (hdr.ver == PopCap_Custom_Lua5)
        {
            PopCap_Custom_LuaOpCode plop[codesz];
        }
        else
        {
            LuaOpCode lop[codesz];
        }
    } code<bgcolor=cRed, optimize=false>;
    //isSubFunc = 0;
};

struct LuaCompiled
{
    uint32 BZLACheck<hidden=true>;
    FSkip(-4);
    if (BZLACheck == 1095522882) //NW Bezel Luac
    {
        FSkip(16);
    }
    FSkip(4);
    byte verChk<hidden=true>;
    FSkip(-5);
    if (verChk == 'P') //52 / 5.2
    {
        Printf("Lua 5.0 files are WIP!\n");
        //break;
    }
    if (verChk == 'R') //52 / 5.2
    {
        Printf("Please use Luac.bt instead.\n");
        break;
    }
    if (verChk == 'V') //PopCap/SAF PopLua
    {
        Printf("PopCap LUC files are WIP!\n");
        //break;
    }
    struct Header
    {
        uint32 magic; // x1BLua
        LuaVersion ver; //P, Q and V (PopLua)
        //check for ChunkSpy 5.1 Lua bcz sure broken rn
        /*FSkip(1);
        byte csChk<hidden=true>;
        FSkip(-2);
        */
        if (ver > 'P' /*&& csChk != 0x04*/)
        {
            byte format; //0: Official, 1: Modified (like PopLua)
        }
        byte endian; //0: Big, 1: Little (For PopLua, always LE, 2 uses unicode [Wrapper])
        if (endian == 0 && ver != PopCap_Custom_Lua5)
        {
            BigEndian();
        }
        if (endian == 1)
        {
            LittleEndian();
        }
        byte intSz;
        byte size_t_sz;
        byte instruction_sz;
        byte lua_number_sz;
        if (ver >= 'P' /*&& csChk != 0x04*/)
        {
            byte integralFlag;
        }
        if (ver < 'Q' || ver == 'V' /*&& (ver > 'P' && csChk != 0x04)*/)
        {
            byte asz;
            byte bsz;
            byte csz;
            //double testNum; //PI
        }
        /*if (ver > 'P' && csChk != 0x04)
        {
            byte integralFlag;
        }*/
        if (ReadInt64() == 4719198358794865078 || ReadInt64() == 4719198358651011072) // do this so 5.0 and 5.1 don't break
        {
            double testNum;
        }
    } hdr<bgcolor=cBlue>;
    LuaString srcName<bgcolor=cGreen>;
    LuaFunction lf<bgcolor=cPurple>;
    FPos = FTell();
    if (hdr.ver < 'P' || hdr.ver == 'V' && FPos < EOF) //todo: Move this
    {
        uint32 subfunctions<bgcolor=cLtPurple>;
        isSubFunc = 1;
        LuaFunction lsf[subfunctions]<bgcolor=cLtPurple, optimize=false>;
        while (FPos < EOF) //Just detect as many
        {
            if (ReadInt() == 0)
            {
                LuaFunction lsf2<optimize=false>; //hack prob will break
            }
            else
            {
                struct Code3
                {
                    uint32 codesz3;
                    if (hdr.ver == PopCap_Custom_Lua5)
                    {
                        PopCap_Custom_LuaOpCode plop2[codesz3];
                    }
                    else
                    {
                        LuaOpCode lop2[codesz3];
                    }
                } code3<bgcolor=cRed, optimize=false>;
            }
            FPos = FTell(); //Check for end
        }
    }
} LUAC;