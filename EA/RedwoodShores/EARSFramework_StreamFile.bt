//------------------------------------------------
//--- 010 Editor v15.0.2 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint i <hidden=true> = 0; //Todo move to LHR

//https://github.com/misternebula/Visceral-File-Formats/wiki/Storage-File
//https://github.com/misternebula/TSGFileViewer/blob/main/Assets/Scripts/EAStreamFile.cs
//https://aluigi.altervista.org/bms/simpsons_str.bms
//https://github.com/gibbed/Gibbed.Visceral/
//https://github.com/Greavesy1899/VisceralToolkit

typedef struct StreamFile
{
    uint32 hash;
    uint32 fileNameOff;
    ubyte parents;
    ubyte force;
    ubyte sections;
    ubyte flags;
    uint32 pad;
    uint32 relsOff;
    uint32 secInfoOff;
    struct
    {
        uint32 off;
        //struct StreamFile str;
    } Parent[parents]<optimize=false>;
};

BigEndian();

//ONLY TESTED ON X360 TSG NG, DO NOT EXPECT IT TO WORK ELSEWHERE

struct
{
    struct
    {
        char magic[4]; //SToc
        uint32 version; //7: TSG
        ubyte sections;
        ubyte platId; //4: X360
        ubyte pad[2];
        uint32 streamFileOff;
        uint32 sectionArrayOff;
    } Header;
    
    if (Header.streamFileOff)
    {
        FSeek(Header.streamFileOff);
        StreamFile rootStreamFile<optimize=false>;
    }
    
    if (Header.sectionArrayOff)
    {
        FSeek(Header.sectionArrayOff);
        struct
        {
            uint32 memPolicyHash; //Referenced in streamtoc
            uint32 compressor;
            uint32 size;
            uint32 allocSz;
            uint32 readSz; //Chunk size
            uint32 readOff;
        } SectionArray[Header.sections];
        
        while (ReadUByte() == 0)
            FSkip(1);
            //FSkip(0x800 - (20 + sizeof(SectionArray)));
        
        struct
        {
            //while (sizeof (Section) < SectionArray[i].readSz)
            {
                struct
                {
                    if (ReadUShort() == 0x1607) //Raw
                    {
                        uint16 chunkType;
                        uint32 size; //This isn't padding. Modifying this breaks TSG.
                        ubyte unk[6]; //What's all this?
                        uint32 hSz;
                        if (hSz)
                        {
                            struct
                            {
                                uint32 nameSz;
                                char name[nameSz]; //Source name?
                                GUID uid;
                                uint32 resTypeSz;
                                char resType[resTypeSz];
                                uint32 pathSz;
                                char path[pathSz];
                                uint32 unkSz;
                                char unk[unkSz];
                                uint32 unk2;
                                uint32 fileSize;
                                ubyte pad[hSz - (nameSz + 4 + 16 + resTypeSz + 4 + pathSz + 4 + unkSz + 4) - 8];
                            } ArchivedFileHeader;
                        }
                        ubyte file[ArchivedFileHeader.fileSize];
                    }
                    //else if (ReadUShort() == 0x2207) //Unk
                    
                    else byte refpack[SectionArray[i].readSz]; //10FB most likely
                } Section;
            }
            i++;
            if (i < Header.sections)
            {
                while (ReadUByte() == 0)
                    FSkip(1);
            }
        } Chunk[Header.sections + (Header.streamFileOff ? 1 : 0)]<optimize=false>;
    }
    
} EARSFramework_StreamFile_STR;