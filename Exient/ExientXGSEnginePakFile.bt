//-----------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//   File: ExientXGSEngine_XGSPak.bt
//   Authors: LolHacksRule with inspiration of XPK2.bms
//   Version: 
//   Purpose: 
//  Category: Reverse Engineering
// File Mask: x/0*XPK
//  ID Bytes: 
//   History: 
//-----------------------------------------------------

//PUBLIC VERSION v1

/*
XGSPAK VX only works with games using XGS Engine VX (I think First Touch Games use multiple?), using different versions with them is likely a bad idea as devs can only use one of the three.
XGSPAKV1 can be used with ZLib or Raw content.
Works nearly perfectly on PAKs WITH and WITHOUT folders.
*/

/*
TODO:
Double check XGSPAKV0 from NFS Wii, it's probably similar?
*/

/*
Format info I used:
https://aluigi.altervista.org/bms/angry_birds_go.bms
https://aluigi.altervista.org/bms/angry_birds_starwars.bms
https://aluigi.altervista.org/bms/xpk2.bms
https://aluigi.altervista.org/bms/dls20.bms
*/

local uint i <hidden = true> = 0;
local uint isFTGCustomV1 <hidden = true> = 0; //Set this to 1 if reading V1 paks from First Touch Games without modification as they use v0's folder and file metadata structure, alternatively you can change the version to 00 and then run the template
local uint isABSW_HighResConsole <hidden = true> = 0; //Don't touch, this will automatically be detected

typedef enum <byte > {
    Version0 = 0, //NFS Wii/Trilogy 3DS/DLS
    Version1 = 1, //ABGO V1/ABTF, AB Console Ports
    Version2 = 2, //ABGO V2+
} PakVersion;

typedef enum <int32> {
    RawContent = 0, //ABGO v1.0.0 (iOS), Various
    ZLib = 1, //ABGO/ABTF
    LZ4 = 2, //Furby/F1 Series
} PakCompressionType;

typedef enum <int32> {
    False = 0,
    True = 1,
} i32_bool;

struct XGSPakFile {
    struct Header {
        char BigEndianChecker[3]<hidden=true>;
        if (BigEndianChecker == "XPK")
        {
            BigEndian();
            FSkip(-3); //Go back to 0
            char magic[3] <bgcolor = cLtAqua>; //XPK/KPX
            PakVersion pakVersion<bgcolor = cYellow>;
        } 
        else
        {
            FSkip(-3);
            LittleEndian();
            PakVersion pakVersion < bgcolor = cYellow>;
            char magic[3] <bgcolor = cLtAqua>; //XPK/KPX
        }
        if (pakVersion == Version0)
        {
            //isBigEndian == true;
            Printf("NFS Hot Persuit Wii/AB Trilogy 3DS (XGSPAK V0)\n");
            //BigEndian();
        }
        else if (pakVersion == Version1)
        {
            //isBigEndian == false;
            Printf("Angry Birds Go! / ABSW Console (XGSPAK V1)\n");
            LittleEndian();
        } else if (pakVersion == Version2) {
            //isBigEndian == false;
            Printf("Angry Birds Go! v1+ (XGSPAK V2)\n");
            LittleEndian();
        }
        if (magic == "XPK")
        {
            Printf("Big Endian");
            BigEndian();
            isABSW_HighResConsole = 1;
        } else if (magic == "KPX")
        {
            Printf("Little Endian");
            LittleEndian();
        }
        int32 folderCnt<bgcolor = cRed>;
        int32 fileCnt<bgcolor = cGreen>; // -1
        int32 fileContentTblSize;
        if (pakVersion == Version2)
        {
            PakCompressionType pakCompressionFlag < bgcolor = cPurple>;
            if (pakCompressionFlag == RawContent)
            {
                Printf(" with Raw Content\n");
            } else if (pakCompressionFlag == ZLib)
            {
                Printf(" with ZLib Compression\n");
            } else if (pakCompressionFlag == LZ4)
            {
                Printf(" with LZ4 Compression\n");
            }
        }
        Printf("\n");
    } XGSPakHdr<bgcolor = cBlue>;
    struct FolderBase
    {
        if (XGSPakHdr.pakVersion == Version0 || isFTGCustomV1 == 1)
        {
            int32 nameOff;
            int32 filesInFolder;
            int32 subfolders;
            int32 filesPos;
            int32 foldersPos;
        }
        else if (XGSPakHdr.pakVersion <= Version2 && XGSPakHdr.pakVersion != Version0)
        {
            if (isABSW_HighResConsole == 1)
            {
                int32 dmy1;
                int32 nameOff;
                int32 dmy2;
                int32 filesPos;
                int32 dmy3;
                int32 foldersPos;
                int32 filesInFolder;
                int32 subfolders;
            }
            else
            {
                int32 nameOff;
                int32 dmy1;
                int32 filesPos;
                int32 dmy2;
                int32 foldersPos;
                int32 dmy3;
                int32 filesInFolder;
                int32 subfolders;
            }
        }
    } XGSPakFolderBase[XGSPakHdr.folderCnt]<bgcolor = cRed>;
    struct ContentMetaBase
    {
        if (XGSPakHdr.pakVersion == Version0 || isFTGCustomV1 == 1)
        {
            int32 nameOff;
            int32 dFileSize;
            int32 fileOffset;
            i32_bool isCompressed;
            int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
            int32 cFileSize;
        }
        else if (XGSPakHdr.pakVersion >= Version1)
        {
            if (isABSW_HighResConsole == 1)
            {
                int32 dmy1;
                int32 nameOff;
                int32 dFileSize;
                int32 fileOffset;
                i32_bool isCompressed;
                int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
                int32 cFileSize;
                int32 dmy2;
            }
            else
            {
                int32 nameOff;
                int32 dmy1;
                int32 dFileSize;
                int32 fileOffset;
                i32_bool isCompressed;
                int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
                int32 cFileSize;
                int32 dmy2;
            }
        }
    } XGSPakContentMeta[XGSPakHdr.fileCnt]<bgcolor = cBlue>;
    
    struct PakStringContent
    {
        //Sub 1 to fix a bug with getting another string
        for (i = 0; i < (XGSPakHdr.fileCnt + XGSPakHdr.folderCnt) -1; i++)
        {
            struct PakString
            {
                string theContentName;
            } pakStr;
        }
    } pakStrTbl<bgcolor = cGreen>;
    struct PakContent
    {
        FSeek(XGSPakContentMeta[0].fileOffset);
        if (XGSPakHdr.pakVersion == Version2)
        {
            if (XGSPakHdr.pakCompressionFlag == RawContent)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                    struct TheRawFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theRawContent[XGSPakContentMeta[i].dFileSize];
                    } theRaw;
                }
            }
            else if (XGSPakHdr.pakCompressionFlag == ZLib)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                //isBigEndian == false;
                    struct ZlibCompressedFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theZlibCompressedContent[XGSPakContentMeta[i].cFileSize];
                    } zlib;
                    //LittleEndian();
                }
            }
            else if (XGSPakHdr.pakCompressionFlag == LZ4)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                //isBigEndian == false;
                    struct LZ4CompressedFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theLZ4CompressedContent[XGSPakContentMeta[i].cFileSize];
                    } lz4;
                    //LittleEndian();
                }
            }
        }
        else if (XGSPakHdr.pakVersion <= Version1 || isFTGCustomV1 == 1) //Work with V0 as well so let's save code
        {
            //byte paddingByte;
            for (i = 0; i < XGSPakHdr.fileCnt; i++)
            {
                struct V0_V1_File
                {
                    FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                    //if (isFTGCustomV1 == 1)
                    {
                        if (XGSPakContentMeta[i].isCompressed == True)
                        {
                             byte theZlibCompressedContent[XGSPakContentMeta[i].cFileSize];
                        }
                        else
                        {
                            byte theRawContent[XGSPakContentMeta[i].dFileSize];
                        }
                    }
                } V1FileContent;
            }
        }
    } XGSPakContent<bgcolor = cPurple>;
}
XGSPak;