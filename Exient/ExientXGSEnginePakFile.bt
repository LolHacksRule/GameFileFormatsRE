//-----------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//   File: ExientXGSEngine_XGSPak.bt
//   Authors: LolHacksRule with inspiration of XPK2.bms
//   Version: 
//   Purpose: 
//  Category: Reverse Engineering
// File Mask: x/0*XPK
//  ID Bytes: 
//   History: 
//-----------------------------------------------------

//PUBLIC VERSION v1

/*
XGSPAK VX only works with games using XGS Engine VX (I think First Touch Games use multiple?), using different versions with them is likely a bad idea as devs can only use one of the three.
XGSPAKV1 can be used with ZLib or Raw content.
Works nearly perfectly on PAKs WITH and WITHOUT folders.
*/

/*
TODO:
Double check XGSPAKV0 from NFS Wii, it's probably similar?
Double check ABSW PAKs (So far works with PS3, Wii U)
*/

/*
Format info I used:
https://aluigi.altervista.org/bms/angry_birds_go.bms
https://aluigi.altervista.org/bms/angry_birds_starwars.bms
https://aluigi.altervista.org/bms/xpk2.bms
https://aluigi.altervista.org/bms/dls20.bms
*/

local uint i <hidden = true> = 0;
local uint isFTGCustomV1 <hidden = true> = 0; //Set this to 1 if reading V1 paks from First Touch Games without modification as they use v0's folder and file metadata structure, alternatively you can change the version to 00 and then run the template
local uint isABSW_WiiU <hidden = true> = 0; //Don't touch, this will automatically be detected

typedef enum <byte > {
    Version0 = 0, //NFS Wii/Trilogy 3DS/DLS
    Version1 = 1, //ABGO V1/ABTF, AB Console Ports
    Version2 = 2, //ABGO V2+
} PakVersion;

typedef enum <int32> {
    RawContent = 0, //ABGO v1.0.0 (iOS), Various
    ZLib = 1, //ABGO/ABTF
    LZ4 = 2, //Furby/F1 Series
} PakCompressionType;

typedef enum <int32> {
    False = 0,
    True = 1,
} i32_bool;

struct XGSPakFile {
    struct Header {
        char BigEndianChecker[3]<hidden=true>;
        if (BigEndianChecker == "XPK")
        {
            BigEndian();
            FSkip(-3); //Go back to 0
            char magic[3] <bgcolor = cLtAqua>; //XPK/KPX
            PakVersion pakVersion<bgcolor = cYellow>;
        } 
        else
        {
            FSkip(-3);
            LittleEndian();
            PakVersion pakVersion < bgcolor = cYellow>;
            char magic[3] <bgcolor = cLtAqua>; //XPK/KPX
        }
        if (pakVersion == Version0)
        {
            //isBigEndian == true;
            Printf("NFS Hot Persuit Wii/AB Trilogy 3DS (XGSPAK V0)\n");
            //BigEndian();
        }
        else if (pakVersion == Version1)
        {
            //isBigEndian == false;
            Printf("Angry Birds Go! / ABSW Wii U (XGSPAK V1)\n");
            LittleEndian();
        } else if (pakVersion == Version2) {
            //isBigEndian == false;
            Printf("Angry Birds Go! v1+ (XGSPAK V2)\n");
            LittleEndian();
        }
        if (magic == "XPK")
        {
            Printf("Big Endian");
            BigEndian();
            isABSW_WiiU = 1;
        } else if (magic == "KPX")
        {
            Printf("Little Endian");
            LittleEndian();
        }
        int32 folderCnt<bgcolor = cRed>;
        int32 fileCnt<bgcolor = cGreen>; // -1
        int32 fileContentTblSize;
        if (pakVersion == Version2)
        {
            PakCompressionType pakCompressionFlag < bgcolor = cPurple>;
            if (pakCompressionFlag == RawContent)
            {
                Printf(" with Raw Content\n");
            } else if (pakCompressionFlag == ZLib)
            {
                Printf(" with ZLib Compression\n");
            } else if (pakCompressionFlag == LZ4)
            {
                Printf(" with LZ4 Compression\n");
            }
        }
        else if (pakVersion == Version1)
        {
            Printf("\n");
            if (pakVersion != Version1)
            {
                int32 unknownBytes;
            }
        }
    }
    XGSPakHdr<bgcolor = cBlue>;
    struct FolderBase {
        if (XGSPakHdr.pakVersion == Version0)
        {
            int32 nameOff;
            int32 filesInFolder; //Different on BE?
            int32 subfolders; //Different on BE?
            int32 filesPos; //Different on BE?
            int32 foldersPos; //Different on BE?
        }
        else if (XGSPakHdr.pakVersion == Version1)
        {
            if (isFTGCustomV1 == 1)
            {
                int32 nameOff;
                int32 filesInFolder; //Different on BE?
                int32 subfolders; //Different on BE?
                int32 filesPos; //Different on BE?
                int32 foldersPos; //Different on BE?
            }
            if (isABSW_WiiU == 1)
            {
                int32 dmy1;
                int32 nameOff;
                int32 dmy2;
                int32 filesPos; //Different on BE?
                int32 dmy3;
                int32 foldersPos; //Different on BE?
                int32 filesInFolder; //Different on BE?
                int32 subfolders; //Different on BE?
            }
            else
            {
                int32 nameOff;
                int32 dmy1;
                int32 filesPos; //Different on BE?
                int32 dmy2;
                int32 foldersPos; //Different on BE?
                int32 dmy3;
                int32 filesInFolder; //Different on BE?
                int32 subfolders; //Different on BE?
            }
        }
        else if (XGSPakHdr.pakVersion == Version2)
        {
            int32 nameOff;
            int32 dmy1;
            int32 filesPos; //Different on BE?
            int32 dmy2;
            int32 foldersPos; //Different on BE?
            int32 dmy3;
            int32 filesInFolder; //Different on BE?
            int32 subfolders; //Different on BE?
        }
        //LittleEndian();
        //int32 soon;
        //int32 unk;
    }
    XGSPakFolderBase[XGSPakHdr.folderCnt]<bgcolor = cRed>;
    /*if (XGSPakHdr.pakVersion == Version0)
    {
        //int32 pad[4];
    }
    if (XGSPakHdr.pakVersion == Version1)
    {
        //int32 pad[1];
    }
    if (XGSPakHdr.pakVersion == Version2)
    {
        /*int32 pad;
        struct FolderBase2 {
            int32 theFolder;
            int32 unklol[2];
            if (XGSPakHdr.folderCnt <= 1)
            {
                int32 fileCnt;
            }
            else
            {
                int32 folderCnt; //? 1 Seems to mean none
            }
        } XGSFolderBase2;
    } else if (XGSPakHdr.pakVersion == Version2) {
        int32 pad;
    }*/
    struct ContentMetaBase
    {
        if (XGSPakHdr.pakVersion == Version0)
        {
            int32 nameOff;
            int32 dFileSize;
            int32 fileOffset;
            i32_bool isCompressed;
            int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
            int32 cFileSize;
        }
        if (XGSPakHdr.pakVersion >= Version1)
        {
            if (isFTGCustomV1 == 1)
            {
                int32 nameOff;
                int32 dFileSize;
                int32 fileOffset;
                i32_bool isCompressed;
                int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
                int32 cFileSize;
            }
            if (isABSW_WiiU == 1)
            {
                int32 dmy1;
                int32 nameOff;
                int32 dFileSize;
                int32 fileOffset;
                i32_bool isCompressed;
                int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
                int32 cFileSize;
                int32 dmy2;
            }
            else
            {
                int32 nameOff;
                int32 dmy1;
                int32 dFileSize;
                int32 fileOffset;
                i32_bool isCompressed;
                int32 CRC; //Why is this even here lol it has no effect in preventing RE'ing :) oddly enough it's not present in ABGO v187
                int32 cFileSize;
                int32 dmy2;
            }
        }
    }
    XGSPakContentMeta[XGSPakHdr.fileCnt]<bgcolor = cBlue>;
    /*if (XGSPakHdr.pakVersion == Version0)
    {
        //FSkip(-4);
    }
    if (XGSPakHdr.pakVersion == Version2)
    {
        //int32 dummy;
    }
    if (XGSPakHdr.pakVersion != Version1)
    {
        //byte dbytes[16]<bgcolor = cRed>;
    }*/
    struct PakStringContent
    {
        if (XGSPakHdr.magic == "XPK")
        {
            i = 1; //Fix a bug with getting another string on Wii U
        }
        else
        {
            i = 0;
        }
        for (i; i < XGSPakHdr.fileCnt + XGSPakHdr.folderCnt; i++)
        {
            struct PakString
            {
                string theContentName;
            } pakStr;
        }
    }
    pakStrTbl<bgcolor = cGreen>;
    struct PakContent
    {
        FSeek(XGSPakContentMeta.fileOffset);
        if (XGSPakHdr.pakVersion == Version2)
        {
            if (XGSPakHdr.pakCompressionFlag == RawContent)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                    struct TheRawFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theRawContent[XGSPakContentMeta[i].dFileSize];
                    } theRaw;
                }
            }
            else if (XGSPakHdr.pakCompressionFlag == ZLib)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                //isBigEndian == false;
                    struct ZlibCompressedFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theZlibCompressedContent[XGSPakContentMeta[i].cFileSize];
                    } zlib;
                    //LittleEndian();
                }
            }
            else if (XGSPakHdr.pakCompressionFlag == LZ4)
            {
                for (i = 0; i < XGSPakHdr.fileCnt; i++)
                {
                //isBigEndian == false;
                    struct LZ4CompressedFile
                    {
                        FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                        byte theLZ4CompressedContent[XGSPakContentMeta[i].cFileSize];
                    } lz4;
                    //LittleEndian();
                }
            }
        }
        else if (XGSPakHdr.pakVersion == Version1)
        {
            //byte paddingByte;
            for (i = 0; i < XGSPakHdr.fileCnt; i++)
            {
                struct V1File
                {
                    FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                    //if (isFTGCustomV1 == 1)
                    {
                        if (XGSPakContentMeta[i].isCompressed == True)
                        {
                             byte theContent[XGSPakContentMeta[i].cFileSize];
                        }
                        else
                        {
                            byte theContent[XGSPakContentMeta[i].dFileSize];
                        }
                    }
                } V1FileContent;
            }
        }
        else
        {
            for (i = 0; i < XGSPakHdr.fileCnt; i++)
            {
                FSeek(XGSPakContentMeta[i].fileOffset); //Skip here
                struct V0File
                {
                    if (XGSPakContentMeta[i].isCompressed == True)
                    {
                        byte theZlibContent[XGSPakContentMeta[i].cFileSize];
                    }
                    else
                    {
                        byte theRawContent[XGSPakContentMeta[i].dFileSize];
                    }
                } V0FileContent;
            }
        }
    }
    XGSPakContent<bgcolor = cPurple>;
}
XGSPak;