//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//Format specs:
//Yoshi's Lighthouse: Dream Team Hacking Documentation

#include "ML4Engine_Common.bt"
#include "../../LHR/Common.bt"

local int totalFrames <hidden=true> = 0;
local int totalParts <hidden=true> = 0;
local int isML3R <hidden=true> = 0;

typedef struct Animation
{
    uint16 frameEntriesOff;
    uint16 frameEntriesCnt;
    totalFrames = totalFrames + frameEntriesCnt; //Hack, detect multiple frames
    uint16 animLen;
    uint16 animXFormEntryOff;
    if (isML3R)
    {
        uint16 unk;
        uint16 unk2;
        uint16 unk3;
        uint16 unk4;
    }
};

typedef struct AnimationXForm
{
    //Vector4_F32
};

typedef struct FrameXForm //Check
{
    Vector2_F32 scale;
    Vector2_F32 rot;
    Vector2_F32 trans;
};

typedef struct Frame
{
    uint16 partEntriesOff;
    uint16 partEntriesCnt;
    //totalParts = totalParts + partEntriesCnt; //Hack, detect multiple parts
    uint16 animLenOff;
    uint16 frameXFormEntryOff;
};

typedef struct Part
{
    byte partSizeID;
    byte flip;
    uint16 partXFormationsEntryOff;
    int16 unk;
    uint16 gfxFileOff;
    local uint16 trueGfxFileOff <hidden=false> = gfxFileOff * 64;
    int16 x;
    int16 y;
};

typedef struct ImageInfo
{
    //int16 unk[2]; //first one is most likely images
    int16 images;
    int16 unknowns;
    int16 width;
    int16 height;
    //uint16 intUnkDatas;
    /*if (ObjectSpriteHeader.graphicsfmtid == 0)
    {
        byte unknownDatas[(unknowns*21)-2];
    }
    if (ObjectSpriteHeader.graphicsfmtid == 4)
    {
        byte unknownDatas[unknowns*28];
    }*/
    //uint16 unk; 
    while (FPos < ObjectSpriteHeader.framesOff-(images*8)) //taken from 00002.bin, 00062.bin, 000434.bin of MObj of ML4, either 2, 4 or 6 bytes per entry
    {
        struct
        {
            //byte unkchunk;
            //int16 unk2;
            //int16 unk3;
            //int16 x;
            //int16 y;
            //int16 unk2;
            //int16 w;
            //int16 h;
            byte unk;
        } ImageDef<hidden=true, bgcolor=cRed>;
        FPos = FTell();
    }
    struct //def correct
    {
        int16 x;
        int16 y;
        int16 w;
        int16 h;
    } ImagePlacementDefinitions[images]<bgcolor=cGreen>;
};

typedef struct ML3R_Unknown
{
    BigEndian();
    while (FPos < EOF) 
    {
        byte floatVal;
        FPos = FTell();
    }
};

typedef struct Header
{
    byte animations;
    ML4Engine_TexFmt graphicsfmtid;
    uint16 unk;
    uint32 fSize;
    uint32 gfxFSize;
    //Dies here on ML3R, todo fix
    if (fSize < ReadInt()) //kinda
    {
        isML3R = 1;
        uint32 unk;
        uint32 unk2;
    }
    uint32 framesOff;
    uint32 partsOff;
    uint32 possiblyAnimXFormationsOff;
    uint32 frameTransOff;
    uint32 partTransOff;
    if (isML3R)
    {
        uint32 animFloatsOff;
        uint32 zero;
    }
    byte unk4[64];
};

struct
{
    LittleEndian();
    Header ObjectSpriteHeader;
    Animation Animations[ObjectSpriteHeader.animations]<optimize=false>;
    FPos = FTell();
    if (ObjectSpriteHeader.partsOff == 0)
    {
        ImageInfo ImageInfoData;
        FSeek(ObjectSpriteHeader.framesOff); //For now, idk what those values are
    }
    Frame Frames[totalFrames]<optimize=false>;
    if (ObjectSpriteHeader.partsOff > 0)
    {
        FSeek(ObjectSpriteHeader.partsOff);
        FPos = FTell();
        struct
        {
            while (FPos < ObjectSpriteHeader.possiblyAnimXFormationsOff) 
            {
                Part part<optimize=false>;
                FPos = FTell();
            }
        } Parts;
    }
    FPos = FTell();
    if (FPos != EOF) //For now, replace with possiblyAnimXFormationsOff or frameTransOff or partTransOff
    {
        FSeek(ObjectSpriteHeader.frameTransOff);
        FrameXForm FrameTransform;
    }
    if (isML3R)
    {
        FSeek(ObjectSpriteHeader.animFloatsOff);
        ML3R_Unknown unknown;
    }
} ObjectSprite;