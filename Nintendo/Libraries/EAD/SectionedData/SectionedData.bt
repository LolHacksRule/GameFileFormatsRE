//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../../../LHR/Common.bt"

//https://mk3ds.com/index.php?title=KMP_(File_Format)
//https://wiki.tockdom.com/wiki/KMP_(File_Format)
//iirc avsys wiki had this documented at least for MK7 but it's lost media now

//Shoutouts to course.0

//Used in NDogs CTR and MK 2008+ series (Wii,7,8/+[?]), not specific to MK

typedef enum <uint32>
{
    SectionType_MK_RevolutionKartMapData = 1380666692,
    SectionType_MK_CTRDashMapData = 1128549700,
    SectionType_MK_CTRDashDiv = 1111573571, //?
    SectionType_MK_KartPoint = 1263816788,
    SectionType_MK_EnemyPoint = 1162760276,
    SectionType_MK_EnemyPath = 1162760264,
    SectionType_MK_ItemPoint = 1230262356,
    SectionType_MK_ItemPath = 1230262344,
    SectionType_MK_CheckPoint = 1129009236,
    SectionType_MK_CheckPointPath = 1129009224,
    SectionType_MK_GlobalObject = 1196376650,
    SectionType_MK_PointInformation = 1347376201,
    SectionType_MK_Area = 1095910721,
    SectionType_MK_Camera = 1128353093,
    SectionType_MK_JugemPoint = 1246187604,
    SectionType_MK_CannonPoint = 1129205844,
    SectionType_MK_MissionSuccessPoint = 1297305684,
    SectionType_MK_StageInfo = 1398032201,
    SectionType_MK_CORS = 1129271891, //CTR
    SectionType_MK_GliderPoint = 1196183636, //CTR
    SectionType_MK_GliderPath = 1196183624, //CTR
    SectionType_MK_Shape = 1397244240, //CTR
    //NDogs CTR
    SectionType_NDogsCTR_Accessory = 1498563393,
    SectionType_NDogsCTR_AccessoryParam = 1297240129,
    SectionType_NDogsCTR_AnimalTypeParam = 1297110081,
    SectionType_NDogsCTR_AnimalTypePC = 1129337921,
    SectionType_NDogsCTR_AnimalTypeAG = 1195463745,
    SectionType_NDogsCTR_AnimalTypeHL = 1279808577,
    SectionType_NDogsCTR_AnimalTypeScale = 1129534529,
    SectionType_NDogsCTR_AnythingHD = 1145589313,
    SectionType_NDogsCTR_AnythingPS = 1397771841,
    SectionType_NDogsCTR_AnythingLT = 1414286913,
    SectionType_NDogsCTR_CompeDN = 1313096771,
    SectionType_NDogsCTR_CompeCP = 1346587715,
    SectionType_NDogsCTR_CompeCL = 1279478851,
    SectionType_NDogsCTR_CompeCameraParam = 1297105731,
    SectionType_NDogsCTR_CompeCameraPF = 1179665219,
    SectionType_NDogsCTR_CompeCameraPA = 1095779139,
    SectionType_NDogsCTR_CompeCameraP2 = 844120899,
    SectionType_NDogsCTR_CompeCameraPC = 1129333571,
    SectionType_NDogsCTR_CompeCameraPD = 1146110787,
    SectionType_NDogsCTR_CompeCameraPR = 1380991811,
    SectionType_NDogsCTR_CompeCameraPS = 1397769027,
    SectionType_NDogsCTR_DogCameraParam = 1297105732,
    SectionType_NDogsCTR_DogCameraBS = 1396851524,
    SectionType_NDogsCTR_DogCameraPF = 1179665220,
    SectionType_NDogsCTR_DogCameraOS = 1397703492,
    SectionType_NDogsCTR_DogCameraCO = 1129268036,
    SectionType_NDogsCTR_DogParameter = 1414352964, //Table?
    SectionType_NDogsCTR_DogParameterIV = 1447642948,
    SectionType_NDogsCTR_DogParameterVB = 1112950596,
    SectionType_NDogsCTR_CatParameterVB = 1112953923, //In DogParameter confusing
    SectionType_NDogsCTR_DogParameterTG = 1196705604,
    SectionType_NDogsCTR_DogParameterDT = 1413760836,
    SectionType_NDogsCTR_DogParameterLT = 1414285124,
    SectionType_NDogsCTR_DogParameterSL = 1280526148,
    SectionType_NDogsCTR_DogParameterOW = 1464813380,
    SectionType_NDogsCTR_DogParameterNL = 1280198468,
    SectionType_NDogsCTR_DogParameterPS = 1397770052,
    SectionType_NDogsCTR_DogParameterST = 1414743876,
    SectionType_NDogsCTR_DogParameterFG = 1195788100,
    SectionType_NDogsCTR_DogParameterWK = 1264011076, //Walk?
    SectionType_NDogsCTR_DogParameterLK = 1263290180, //Like?
    SectionType_NDogsCTR_DogParameterEV = 1447380804, //Like?
    SectionType_NDogsCTR_DogParameterWT = 1415006020, //Wait?
    SectionType_NDogsCTR_DogParameterCB = 1111705412,
    SectionType_NDogsCTR_DogParameterSP = 1347635012,
    SectionType_NDogsCTR_DogParameterSTTM = 1297372243,
    SectionType_NDogsCTR_DogParameterWGST = 1398032215,
    SectionType_NDogsCTR_DogParameterIVMP = 1297110601,
    SectionType_NDogsCTR_DogParameterHUMC = 1129141576,
    SectionType_NDogsCTR_DogEffects = 1179010372,
    SectionType_NDogsCTR_EffectsDS = 1396983365,
    SectionType_NDogsCTR_EffectsBB = 1111639621,
    SectionType_NDogsCTR_EffectsBC = 1128416837,
    SectionType_NDogsCTR_EffectsLB = 1279411781,
    SectionType_NDogsCTR_EffectsBF = 1178748485,
    SectionType_NDogsCTR_EffectsDT = 1413760581,
    SectionType_NDogsCTR_EffectsCF = 1178814021,
    SectionType_NDogsCTR_EffectsFS = 1397114437,
    SectionType_NDogsCTR_FieldMap = 1297237571,
    SectionType_NDogsCTR_FieldMapFurniture = 1413891651,
    SectionType_NDogsCTR_FieldMapTGRO = 1330792276,
    SectionType_NDogsCTR_FieldMapRADG = 1195655506,
    SectionType_NDogsCTR_FieldMapREAD = 1145389394,
    SectionType_NDogsCTR_FieldMapRAFZ = 1514553682,
    SectionType_NDogsCTR_FieldMapRACR = 1380139346,
    SectionType_NDogsCTR_FieldMapRADZ = 1514422610,
    SectionType_NDogsCTR_FieldMapRALZ = 1514946898,
    SectionType_NDogsCTR_FieldMapRACZ = 1514357074,
    SectionType_NDogsCTR_FieldMapRDPU = 1431323730,
    SectionType_NDogsCTR_FieldMapRDPA = 1095779410,
    SectionType_NDogsCTR_FieldMapRDPL = 1280328786,
    SectionType_NDogsCTR_FieldMapRDPH = 1213219922,
    SectionType_NDogsCTR_FieldMapRDHH = 1212695634,
    SectionType_NDogsCTR_FieldMapROPW = 1464880978,
    SectionType_NDogsCTR_FieldMapROPT = 1414549330,
    SectionType_NDogsCTR_FieldMapROPC = 1129336658,
    SectionType_NDogsCTR_FieldMapROCS = 1396920146,
    SectionType_NDogsCTR_FieldMapROCP = 1346588498,
    SectionType_NDogsCTR_FieldMapROOP = 1347374930,
    SectionType_NDogsCTR_FieldMapROAL = 1279348562,
    SectionType_NDogsCTR_FieldMapRDPO = 1330660434,
    SectionType_NDogsCTR_FieldMapRCMR = 1380795218,
    SectionType_NDogsCTR_FieldMapRCMG = 1196245842,
    SectionType_NDogsCTR_FieldMapFUNM = 1297436230,
    //Exclusive to furniture?
    SectionType_NDogsCTR_FieldMapTGFT = 1413891924,
    SectionType_NDogsCTR_FieldMapFOPR = 1380994886,
    SectionType_NDogsCTR_FieldMapFOPW = 1464880966,
    SectionType_NDogsCTR_FieldMapFOPA = 1095782214,
    SectionType_NDogsCTR_FieldMapFOPO = 1330663238,
    SectionType_NDogsCTR_FieldMapFOPL = 1280331590,
    SectionType_NDogsCTR_FieldMapFARE = 1163018566,
    SectionType_NDogsCTR_FieldMapFDPO = 1330660422,
    SectionType_NDogsCTR_FieldMapFDPU = 1431323718,
    SectionType_NDogsCTR_FieldMapFDPA = 1095779398,
    SectionType_NDogsCTR_FieldMapFDPP = 1347437638,
    SectionType_NDogsCTR_FieldMapFDPH = 1213219910,
    SectionType_NDogsCTR_FieldMapFDPT = 1414546502,
    SectionType_NDogsCTR_FieldMapFCAM = 1296122694,
    SectionType_NDogsCTR_FieldMapFPCM = 1296257094,
    //Exclusive to goods?
    SectionType_NDogsCTR_FieldMapCFGD = 1145521731,
    SectionType_NDogsCTR_FieldMapRDOB = 1112556626,
    SectionType_NDogsCTR_Goods = 1396985671,
    SectionType_NDogsCTR_GoodsParam = 1297240135,
    SectionType_NDogsCTR_GoodsRParam = 1297109575, //Rare/Res?
    SectionType_NDogsCTR_MiiInfo = 1229539661,
    SectionType_NDogsCTR_MiiVIS = 1397315149, //Visibility?
    SectionType_NDogsCTR_MiiNPC = 1129336397,
    SectionType_NDogsCTR_Shared = 1146243155,
    SectionType_NDogsCTR_SharedTCM = 1296258131,
} SectionType;

typedef enum <byte>
{
    MK_CheckpointType_NormalCheckPoint = -1,
    MK_CheckpointType_LapCountTrigger,
} MK_CheckpointType;

typedef struct SectionHeader
{
    SectionType magic;
    if (Header.magic != SectionType_MK_RevolutionKartMapData || Header.magic == SectionType_MK_CTRDashDiv)
    {
        LittleEndian();
    }
    uint16 entries;
    uint16 other;
};

typedef struct MK_KartPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 pos;
            Vector3_F32 start;
            uint16 playerIndex;
            uint16 pad;
        } MK_KartPointEntry[h.entries];
    }
};

typedef struct MK_EnemyPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 enemyPos;
            float start;
            if (Header.magic != SectionType_MK_RevolutionKartMapData)
            {
                uint16 pad[4]; //?
            }
            else
            {
                uint16 pointSetting1;
                byte otherPointSetting[2];
            }
        } MK_EnemyPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_EnemyPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            if (Header.magic != SectionType_MK_RevolutionKartMapData)
            {
                uint16 pointStart;
                uint16 pointLen;
                int16 prevGroup[16]; //16 previous enemy points
                int16 nextGroup[16]; //16 next enemy points
                uint32 bitFlag; //?
            }
            else
            {
                ubyte pointStart;
                ubyte pointLen;
                byte prevGroup[6]; //6 previous enemy points
                byte nextGroup[6]; //6 next enemy points
                short bitFlag;
            }
        } MK_EnemyPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_ItemPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 itemPos;
            float bb;
            uint16 setting1;
            uint16 setting2; //Two u16s compared to MK7, being a u32, assuming since the header size is the same across both
        } MK_ItemPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_ItemPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            if (Header.magic != SectionType_MK_RevolutionKartMapData)
            {
                uint16 pointStart;
                uint16 pointLen;
                int16 prevGroup[6]; //6 previous item points
                int16 nextGroup[6]; //6 next item points
            }
            else
            {
                ubyte pointStart;
                ubyte pointLen;
                byte prevGroup[6]; //6 previous item points
                byte nextGroup[6]; //6 next item points
                uint16 pad;
            }
        } MK_ItemPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_CheckPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector2_F32 leftPoint;
            Vector2_F32 rightPoint;
            byte respawnID;
            MK_CheckpointType CheckpointType;
            byte prevCheckPoint;
            byte nextCheckPoint;
            if (Header.magic != SectionType_MK_RevolutionKartMapData)
            {
                byte unk[4];
            }
        } MK_CheckPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_CheckPointPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            ubyte pointStart;
            ubyte pointLen;
            byte prevGroup[6]; //6 previous checkpoints
            byte nextGroup[6]; //6 next checkpoints
            uint16 pad; //Padding in MKW so assuming padding
        } MK_CheckPointPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_GlobalObject
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint16 objectID;
            uint16 pad; //Padding in MKW so assuming padding
            Vector3_F32 pos;
            Vector3_F32 rot;
            Vector3_F32 scl;
            uint16 route;
            uint16 setting[8];
            uint16 presenceFlags;
            if (Header.magic != SectionType_MK_RevolutionKartMapData)
            {
                byte unk[4];
            }
        } MK_GlobalObjectEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_PointInformation
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint16 points;
            byte setting1;
            byte setting2;
            struct
            {
                Vector3_F32 pos;
                uint16 routePointSetting;
                uint16 additionalSetting;
            } MK_PointEntry[points];
        } MK_PointInformationEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_Area
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte shape;
            byte type;
            byte cameraIdx;
            byte priority;
            Vector3_F32 pos;
            Vector3_F32 rot;
            Vector3_F32 scl;
            uint16 setting1;
            uint16 setting2;
            byte routeID;
            byte enemyPointID;
            uint16 pad;
        } MK_AreaEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_Camera
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte type;
            byte nextCameraIdx;
            byte shake;
            byte route;
            uint16 cameraPointVel;
            uint16 zoomVel;
            uint16 viewPointVel;
            byte startFlag;
            byte movieFlag;
            Vector3_F32 pos;
            Vector3_F32 rot;
            float zoomStart;
            float zoomEnd;
            Vector3_F32 viewPointStartVec;
            Vector3_F32 viewPointDestVec;
            float activeTime;
        } MK_CameraEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_JugemPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 respawn;
            Vector3_F32 direction;
            uint16 respawnPosID;
            int16 extraFlag;
        } MK_JugemPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_CannonPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 dest;
            Vector3_F32 direction;
            uint16 id;
            int16 shootEffect;
        } MK_CannonPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_MissionSuccessPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 dest;
            Vector3_F32 direction;
            uint16 id;
            uint16 unk; //Effect, unused, looks similar to cannon point so assuming?
        } MK_MissionSuccessPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_StageInfo
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte laps;
            byte polePos;
            byte normalDist;
            byte lensFlare;
            uint32 lensFlareColor;
            byte flareTrans;
            uint16 pad;
            byte pad2;
        } MK_StageInfoEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_CORSSection
{
    SectionHeader h; //Unused
};

typedef struct MK_GliderPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 pos;
            float scale;
            uint32 unk[2];
        } MK_GliderPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_GliderPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte pointStart;
            byte pointEnd;
            byte prevGroups[6];
            byte nextGroups[6];
            uint32 unk[2];
        } MK_GliderPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct MK_Shape
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            SectionHeader sh; //STRM
            Vector4_F32 v3f[sh.entries];
        } MK_Shape_STRMEntry[h.entries]<optimize=false>;
    }
};

typedef struct NDogsCTR_AccessoryParam
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x530];
        } AccessoryParamEntry[h.entries]<optimize=false>;
    }
};

typedef struct NDogsCTR_AnimalTypePC
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x98];
        } AnimalTypePCEntry[h.entries]<optimize=false>;
    }
};

typedef struct NDogsCTR_AnimalTypeAG
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x2c];
        } AnimalTypeAGEntry[h.entries]<optimize=false>;
    }
};

typedef struct NDogsCTR_AnimalTypeHL
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct //float data
        {
            byte unk[0x30];
        } AnimalTypeHLEntry[h.entries]<optimize=false>;
    }
};

typedef struct NDogsCTR_AnimalTypeScale
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector4_F32 entry[h.entries/4];
    }
};

typedef struct NDogsCTR_AnythingHD
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector3_F32 NDogsCTR_AnythingHDEntry[h.entries];
    }
};

typedef struct NDogsCTR_AnythingPS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector3_F32 NDogsCTR_AnythingPSEntry[h.entries];
    }
};

typedef struct NDogsCTR_AnythingLT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector3_F32 NDogsCTR_AnythingLTEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeDN
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x0c];
        } NDogsCTR_CompeDNEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCP
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte floats[0x1c];
        } NDogsCTR_CompeCPEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCL
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte floats[0x20]; //Floats
        } NDogsCTR_CompeCLEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompePF
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte floats[0x20]; //Floats
        } NDogsCTR_CompePFEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPF
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x24]; //Floats
        } NDogsCTR_CompeCameraPFEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPA
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x2c]; //Floats
        } NDogsCTR_CompeCameraPAEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraP2
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats
        } NDogsCTR_CompeCameraP2Entry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPC
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x24]; //Floats
        } NDogsCTR_CompeCameraPCEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPD
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x28]; //Floats
        } NDogsCTR_CompeCameraPDEntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPR
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x28]; //Floats
        } NDogsCTR_CompeCameraPREntry[h.entries];
    }
};

typedef struct NDogsCTR_CompeCameraPS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x2C]; //Floats
        } NDogsCTR_CompeCameraPSEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogCameraBS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector4_F32 NDogsCTR_DogCameraBSEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogCameraPF
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector4_F32 min;
            Vector4_F32 max;
        } NDogsCTR_DogCameraPFEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogCameraOS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct //?
        {
            Vector3_F32 min;
            Vector3_F32 max;
        } NDogsCTR_DogCameraOSEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogCameraCO
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct //?
        {
            Vector3_F32 min;
            Vector3_F32 max;
        } NDogsCTR_DogCameraCOEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterIV
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct //?
        {
            byte unk[0x10];
        } NDogsCTR_DogParameterIVEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterVB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector4_F32 NDogsCTR_DogParameterVBEntry[h.entries];
    }
};

typedef struct NDogsCTR_CatParameterVB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector4_F32 NDogsCTR_CatParameterVBEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterTG
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector3_F32 NDogsCTR_DogParameterTGEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterDT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x1C]; //Floats for sure
        } NDogsCTR_DogParameterDTEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterLT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x1c]; //Floats for sure
        } NDogsCTR_DogParameterLTEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterSL
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x18]; //Floats for sure
        } NDogsCTR_DogParameterSLEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterOW
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x8]; //Floats for sure
        } NDogsCTR_DogParameterOWEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterNL
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x1c];
        } NDogsCTR_DogParameterNLEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterPS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x14]; //Floats for sure
        } NDogsCTR_DogParameterPSEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterST
{
    SectionHeader h;
    if (h.entries != 0)
    {
        float NDogsCTR_DogParameterSTEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterFG
{
    SectionHeader h;
    if (h.entries != 0)
    {
        float NDogsCTR_DogParameterFGEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterWK
{
    SectionHeader h;
    if (h.entries != 0)
    {
        float NDogsCTR_DogParameterWKEntry[h.entries];
    }
};


typedef struct NDogsCTR_DogParameterLK
{
    SectionHeader h;
    if (h.entries != 0)
    {
        float NDogsCTR_DogParameterLKEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterEV
{
    SectionHeader h;
    if (h.entries != 0)
    {
        float NDogsCTR_DogParameterEVEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterWT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        Vector2_F32 NDogsCTR_DogParameterWTEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterCB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x0C];
        } NDogsCTR_DogParameterCBEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterSP
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint32 unk[2];
            float unk2;
        } NDogsCTR_DogParameterSPEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterSTTM
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint32 unk;
        } NDogsCTR_DogParameterSPEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterWGST
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            //min max unk?
            byte unk[0x14];
        } NDogsCTR_DogParameterWGSTEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterIVMP
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint32 unk[2];
            Vector2_F32 unk2;
        } NDogsCTR_DogParameterIVMPEntry[h.entries];
    }
};

typedef struct NDogsCTR_DogParameterHUMC
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint32 unk[2];
        } NDogsCTR_DogParameterHUMCEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapTGRO
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector4_F32 v4f;
        } NDogsCTR_DogParameterTGROEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRADG
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats
        } NDogsCTR_DogParameterRADGEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapREAD
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats mostly
        } NDogsCTR_DogParameterREADEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRAFZ
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats mostly
        } NDogsCTR_DogParameterRAFZEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRACR
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats mostly
        } NDogsCTR_DogParameterRACREntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRADZ
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapRALZ
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapRACZ
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats mostly
        } NDogsCTR_DogParameterRACZEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRDPU
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            uint16 unk[2];
            uint32 unk2; //or two i16s/four bytes
        } NDogsCTR_DogParameterDRPUEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRDPA
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[8];
        } NDogsCTR_DogParameterRDPAEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRDPL
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapRDPH
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapRDHH
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapROPW
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20]; //Two V4Fs?
        } NDogsCTR_DogParameterROPWEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapROPT
{
    SectionHeader h; //Empty
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20]; //floats are split per byte
        } NDogsCTR_DogParameterROPTEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapROPC
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapROCS
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapROCP
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapROOP
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapROAL
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapRDPO
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x10]; //Two V4Fs?
        } NDogsCTR_DogParameterRDPOEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRCMR
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x48]; //Mostly floats?
        } NDogsCTR_DogParameterRCMREntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRCMG
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFUNM
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint32 test;
        } NDogsCTR_FieldMapFUNMEntry[h.entries];
        //uint32 pad; //?
    }
};



typedef struct NDogsCTR_FieldMapTGFT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x3C]; //This is inconsistent and may use 0x40 size 
        } NDogsCTR_FieldMapTGFTEntry[h.entries];
        if (ReadInt() == 0) // fix I hope
        {
            uint32 pad;
        }
    }
};

typedef struct NDogsCTR_FieldMapFOPR
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20];
        } NDogsCTR_FieldMapFOPREntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFOPW
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20];
        } NDogsCTR_FieldMapFOPWEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFOPA
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFOPO
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFOPL
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20];
        } NDogsCTR_FieldMapFOPLEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFARE
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30];
        } NDogsCTR_FieldMapFAREEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFDPO
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x10];
        } NDogsCTR_FieldMapFDPOEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFDPU
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x08];
        } NDogsCTR_FieldMapFDPUEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFDPA
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x08];
        } NDogsCTR_FieldMapFDPAEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFDPP
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFDPH
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFDPT
{
    SectionHeader h; //Empty
};

typedef struct NDogsCTR_FieldMapFCAM
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20];
        } NDogsCTR_FieldMapFCAMEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapFPCM
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x20];
        } NDogsCTR_FieldMapFPCMEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsDS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x18];
        } NDogsCTR_EffectsDSEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsBB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //Floats?
        } NDogsCTR_EffectsBBEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsBC
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //I16/I32 and Floats?
        } NDogsCTR_EffectsBCEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsLB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //I16/I32 and Floats?
        } NDogsCTR_EffectsLBEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsBF
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //I16/I32 and Floats?
        } NDogsCTR_EffectsBFEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsDT
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x30]; //I16/I32 and Floats?
        } NDogsCTR_EffectsDTEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsCF
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x2C]; //I16/I32 and Floats?
        } NDogsCTR_EffectsCFEntry[h.entries];
    }
};

typedef struct NDogsCTR_EffectsFS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x24]; //Floats?
        } NDogsCTR_EffectsFSEntry[h.entries];
    }
};

typedef struct NDogsCTR_FieldMapRDOB
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x8];
        } NDogsCTR_FieldMapRDOBEntry[h.entries];
    }
};

typedef struct NDogsCTR_GoodsParam
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x284];
        } NDogsCTR_GoodsParamEntry[h.entries];
    }
};

typedef struct NDogsCTR_GoodsRParam
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x3C];
        } NDogsCTR_GoodsRParamEntry[h.entries];
    }
};

typedef struct NDogsCTR_SharedTCM
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x0C]; //Floats
        } NDogsCTR_SharedTCMEntry[h.entries];
    }
};

typedef struct NDogsCTR_MiiVIS
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[0x1C]; //Floats and ints?
        } NDogsCTR_MiiVISEntry[h.entries];
    }
};

typedef struct NDogsCTR_MiiNPC
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte unk[4]; //ints/shorts/bytes?
        } NDogsCTR_MiiNPCEntry[h.entries];
    }
};


struct
{
    struct
    {
        BigEndian();
        if (ReadUInt() != SectionType_MK_RevolutionKartMapData) //Revolution Kart Map Data
        {
            LittleEndian();
        }
        SectionType magic;
        uint32 fSize;
        uint16 sections;
        uint16 hLen;
        uint32 version;
        if (magic != SectionType_MK_CTRDashDiv)
        {
            uint32 sectionOffsets[sections]; //Kart Map Data only
        }
        //Lazy so shape will error for now
    } Header;
    for (i; i < Header.sections; i++)
    {
        switch (ReadInt())
        {
            //MK
            case SectionType_MK_KartPoint: MK_KartPoint MK_KTPT; break;
            case SectionType_MK_EnemyPoint: MK_EnemyPoint MK_ENPT; break;
            case SectionType_MK_EnemyPath: MK_EnemyPath MK_ENPH; break;
            case SectionType_MK_ItemPoint: MK_ItemPoint MK_ITPT; break;
            case SectionType_MK_ItemPath: MK_ItemPath MK_ITPH; break;
            case SectionType_MK_CheckPoint: MK_CheckPoint MK_CKPT; break;
            case SectionType_MK_CheckPointPath: MK_CheckPointPath MK_CKPH; break;
            case SectionType_MK_GlobalObject: MK_GlobalObject MK_GOBJ; break;
            case SectionType_MK_PointInformation: MK_PointInformation MK_POTI; break;
            case SectionType_MK_Area: MK_Area MK_AREA; break;
            case SectionType_MK_Camera: MK_Camera MK_CAME; break;
            case SectionType_MK_JugemPoint: MK_JugemPoint MK_JGPT; break;
            case SectionType_MK_CannonPoint: MK_CannonPoint MK_CNPT; break;
            case SectionType_MK_MissionSuccessPoint: MK_MissionSuccessPoint MK_MSPT; break;
            case SectionType_MK_StageInfo: MK_StageInfo MK_STGI; break;
            case SectionType_MK_CORS: MK_CORSSection MK_CORS; break; //CTR
            case SectionType_MK_GliderPoint: MK_GliderPoint MK_GLPT; break; //CTR
            case SectionType_MK_GliderPath: MK_GliderPath MK_GLPH; break; //CTR
            case SectionType_MK_Shape: MK_Shape MK_SHAP; break; //CTR
            //NDogs CTR
            case SectionType_NDogsCTR_AccessoryParam: NDogsCTR_AccessoryParam NDogsCTR_APRM; break;
            case SectionType_NDogsCTR_AnimalTypePC: NDogsCTR_AnimalTypePC NDogsCTR_ATPC; break;
            case SectionType_NDogsCTR_AnimalTypeAG: NDogsCTR_AnimalTypeAG NDogsCTR_ATAG; break;
            case SectionType_NDogsCTR_AnimalTypeHL: NDogsCTR_AnimalTypeHL NDogsCTR_ATHL; break;
            case SectionType_NDogsCTR_AnimalTypeScale: NDogsCTR_AnimalTypeScale NDogsCTR_ATSC; break;
            case SectionType_NDogsCTR_AnythingHD: NDogsCTR_AnythingHD NDogsCTR_ANHD; break;
            case SectionType_NDogsCTR_AnythingPS: NDogsCTR_AnythingPS NDogsCTR_ANPS; break;
            case SectionType_NDogsCTR_AnythingLT: NDogsCTR_AnythingLT NDogsCTR_ANLT; break;
            case SectionType_NDogsCTR_CompeDN: NDogsCTR_CompeDN NDogsCTR_CDDN; break;
            case SectionType_NDogsCTR_CompeCP: NDogsCTR_CompeCP NDogsCTR_CLCP; break;
            case SectionType_NDogsCTR_CompeCL: NDogsCTR_CompeCL NDogsCTR_CLCL; break;
            case SectionType_NDogsCTR_CompeCameraPF: NDogsCTR_CompeCameraPF NDogsCTR_CCPF; break;
            case SectionType_NDogsCTR_CompeCameraPA: NDogsCTR_CompeCameraPA NDogsCTR_CCPA; break;
            case SectionType_NDogsCTR_CompeCameraP2: NDogsCTR_CompeCameraP2 NDogsCTR_CCP2; break;
            case SectionType_NDogsCTR_CompeCameraPC: NDogsCTR_CompeCameraPC NDogsCTR_CCPC; break;
            case SectionType_NDogsCTR_CompeCameraPD: NDogsCTR_CompeCameraPD NDogsCTR_CCPD; break;
            case SectionType_NDogsCTR_CompeCameraPR: NDogsCTR_CompeCameraPR NDogsCTR_CCPR; break;
            case SectionType_NDogsCTR_CompeCameraPS: NDogsCTR_CompeCameraPS NDogsCTR_CCPS; break;
            case SectionType_NDogsCTR_DogCameraBS: NDogsCTR_DogCameraBS NDogsCTR_DCBS; break;
            case SectionType_NDogsCTR_DogCameraPF: NDogsCTR_DogCameraPF NDogsCTR_DCPF; break;
            case SectionType_NDogsCTR_DogCameraOS: NDogsCTR_DogCameraOS NDogsCTR_DCOS; break;
            case SectionType_NDogsCTR_DogCameraCO: NDogsCTR_DogCameraCO NDogsCTR_DCCO; break;
            case SectionType_NDogsCTR_DogParameterIV: NDogsCTR_DogParameterIV NDogsCTR_DGIV; break;
            case SectionType_NDogsCTR_DogParameterVB: NDogsCTR_DogParameterVB NDogsCTR_DGVB; break;
            case SectionType_NDogsCTR_CatParameterVB: NDogsCTR_CatParameterVB NDogsCTR_CTVB; break; //Why in DogParameter idk
            case SectionType_NDogsCTR_DogParameterTG: NDogsCTR_DogParameterTG NDogsCTR_DGTG; break;
            case SectionType_NDogsCTR_DogParameterDT: NDogsCTR_DogParameterDT NDogsCTR_DGDT; break;
            case SectionType_NDogsCTR_DogParameterLT: NDogsCTR_DogParameterLT NDogsCTR_DGLT; break;
            case SectionType_NDogsCTR_DogParameterSL: NDogsCTR_DogParameterSL NDogsCTR_DGSL; break;
            case SectionType_NDogsCTR_DogParameterOW: NDogsCTR_DogParameterOW NDogsCTR_DGOW; break;
            case SectionType_NDogsCTR_DogParameterNL: NDogsCTR_DogParameterNL NDogsCTR_DGNL; break;
            case SectionType_NDogsCTR_DogParameterPS: NDogsCTR_DogParameterPS NDogsCTR_DGPS; break;
            case SectionType_NDogsCTR_DogParameterST: NDogsCTR_DogParameterST NDogsCTR_DGST; break;
            case SectionType_NDogsCTR_DogParameterFG: NDogsCTR_DogParameterFG NDogsCTR_DGFG; break;
            case SectionType_NDogsCTR_DogParameterWK: NDogsCTR_DogParameterWK NDogsCTR_DGWK; break;
            case SectionType_NDogsCTR_DogParameterLK: NDogsCTR_DogParameterLK NDogsCTR_DGLK; break;
            case SectionType_NDogsCTR_DogParameterEV: NDogsCTR_DogParameterEV NDogsCTR_DGEV; break;
            case SectionType_NDogsCTR_DogParameterWT: NDogsCTR_DogParameterWT NDogsCTR_DGWT; break;
            case SectionType_NDogsCTR_DogParameterCB: NDogsCTR_DogParameterCB NDogsCTR_DGCB; break;
            case SectionType_NDogsCTR_DogParameterSP: NDogsCTR_DogParameterSP NDogsCTR_DGSP; break;
            case SectionType_NDogsCTR_DogParameterSTTM: NDogsCTR_DogParameterSTTM NDogsCTR_STTM; break;
            case SectionType_NDogsCTR_DogParameterWGST: NDogsCTR_DogParameterWGST NDogsCTR_WGST; break;
            case SectionType_NDogsCTR_DogParameterIVMP: NDogsCTR_DogParameterIVMP NDogsCTR_IVMP; break;
            case SectionType_NDogsCTR_DogParameterHUMC: NDogsCTR_DogParameterHUMC NDogsCTR_HUMC; break;
            case SectionType_NDogsCTR_FieldMapTGRO: NDogsCTR_FieldMapTGRO NDogsCTR_TGRO; break;
            case SectionType_NDogsCTR_FieldMapRADG: NDogsCTR_FieldMapRADG NDogsCTR_RADG; break;
            case SectionType_NDogsCTR_FieldMapREAD: NDogsCTR_FieldMapREAD NDogsCTR_READ; break;
            case SectionType_NDogsCTR_FieldMapRAFZ: NDogsCTR_FieldMapRAFZ NDogsCTR_RAFZ; break;
            case SectionType_NDogsCTR_FieldMapRACR: NDogsCTR_FieldMapRAFZ NDogsCTR_RACR; break;
            case SectionType_NDogsCTR_FieldMapRADZ: NDogsCTR_FieldMapRAFZ NDogsCTR_RADZ; break;
            case SectionType_NDogsCTR_FieldMapRALZ: NDogsCTR_FieldMapRALZ NDogsCTR_RALZ; break;
            case SectionType_NDogsCTR_FieldMapRACZ: NDogsCTR_FieldMapRACZ NDogsCTR_RACZ; break;
            case SectionType_NDogsCTR_FieldMapRDPU: NDogsCTR_FieldMapRDPU NDogsCTR_RDPU; break;
            case SectionType_NDogsCTR_FieldMapRDPA: NDogsCTR_FieldMapRDPA NDogsCTR_RDPA; break;
            case SectionType_NDogsCTR_FieldMapRDPL: NDogsCTR_FieldMapRDPL NDogsCTR_RDPL; break;
            case SectionType_NDogsCTR_FieldMapRDPH: NDogsCTR_FieldMapRDPH NDogsCTR_RDPH; break;
            case SectionType_NDogsCTR_FieldMapRDHH: NDogsCTR_FieldMapRDHH NDogsCTR_RDHH; break;
            case SectionType_NDogsCTR_FieldMapROPW: NDogsCTR_FieldMapROPW NDogsCTR_ROPW; break;
            case SectionType_NDogsCTR_FieldMapROPT: NDogsCTR_FieldMapROPT NDogsCTR_ROPT; break;
            case SectionType_NDogsCTR_FieldMapROPC: NDogsCTR_FieldMapROPC NDogsCTR_ROPC; break;
            case SectionType_NDogsCTR_FieldMapROCS: NDogsCTR_FieldMapROCS NDogsCTR_ROCS; break;
            case SectionType_NDogsCTR_FieldMapROCP: NDogsCTR_FieldMapROCP NDogsCTR_ROCP; break;
            case SectionType_NDogsCTR_FieldMapROOP: NDogsCTR_FieldMapROOP NDogsCTR_ROOP; break;
            case SectionType_NDogsCTR_FieldMapROAL: NDogsCTR_FieldMapROAL NDogsCTR_ROAL; break;
            case SectionType_NDogsCTR_FieldMapRDPO: NDogsCTR_FieldMapRDPO NDogsCTR_RDPO; break;
            case SectionType_NDogsCTR_FieldMapRCMR: NDogsCTR_FieldMapRCMR NDogsCTR_RCMR; break;
            case SectionType_NDogsCTR_FieldMapRCMG: NDogsCTR_FieldMapRCMG NDogsCTR_RCMG; break;
            case SectionType_NDogsCTR_FieldMapFUNM: NDogsCTR_FieldMapFUNM NDogsCTR_FUNM; break;
            case SectionType_NDogsCTR_FieldMapTGFT: NDogsCTR_FieldMapTGFT NDogsCTR_TGFT; break;
            case SectionType_NDogsCTR_FieldMapFOPR: NDogsCTR_FieldMapFOPR NDogsCTR_FOPR; break;
            case SectionType_NDogsCTR_FieldMapFOPW: NDogsCTR_FieldMapFOPW NDogsCTR_FOPW; break;
            case SectionType_NDogsCTR_FieldMapFOPA: NDogsCTR_FieldMapFOPA NDogsCTR_FOPA; break;
            case SectionType_NDogsCTR_FieldMapFOPO: NDogsCTR_FieldMapFOPO NDogsCTR_FOPO; break;
            case SectionType_NDogsCTR_FieldMapFOPL: NDogsCTR_FieldMapFOPL NDogsCTR_FOPL; break;
            case SectionType_NDogsCTR_FieldMapFARE: NDogsCTR_FieldMapFARE NDogsCTR_FARE; break;
            case SectionType_NDogsCTR_FieldMapFDPO: NDogsCTR_FieldMapFDPO NDogsCTR_FDPO; break;
            case SectionType_NDogsCTR_FieldMapFDPU: NDogsCTR_FieldMapFDPU NDogsCTR_FDPU; break;
            case SectionType_NDogsCTR_FieldMapFDPA: NDogsCTR_FieldMapFDPA NDogsCTR_FDPA; break;
            case SectionType_NDogsCTR_FieldMapFDPP: NDogsCTR_FieldMapFDPP NDogsCTR_FDPP; break;
            case SectionType_NDogsCTR_FieldMapFDPH: NDogsCTR_FieldMapFDPH NDogsCTR_FDPH; break;
            case SectionType_NDogsCTR_FieldMapFDPT: NDogsCTR_FieldMapFDPT NDogsCTR_FDPT; break;
            case SectionType_NDogsCTR_FieldMapFCAM: NDogsCTR_FieldMapFCAM NDogsCTR_FCAM; break;
            case SectionType_NDogsCTR_FieldMapFPCM: NDogsCTR_FieldMapFPCM NDogsCTR_FPCM; break;
            case SectionType_NDogsCTR_FieldMapRDOB: NDogsCTR_FieldMapRDOB NDogsCTR_RDOB; break;
            case SectionType_NDogsCTR_EffectsDS: NDogsCTR_EffectsDS NDogsCTR_EFDS; break;
            case SectionType_NDogsCTR_EffectsBB: NDogsCTR_EffectsBB NDogsCTR_EFBB; break;
            case SectionType_NDogsCTR_EffectsBC: NDogsCTR_EffectsBC NDogsCTR_EFBC; break;
            case SectionType_NDogsCTR_EffectsLB: NDogsCTR_EffectsLB NDogsCTR_EFLB; break;
            case SectionType_NDogsCTR_EffectsBF: NDogsCTR_EffectsBF NDogsCTR_EFBF; break;
            case SectionType_NDogsCTR_EffectsDT: NDogsCTR_EffectsDT NDogsCTR_EFDT; break;
            case SectionType_NDogsCTR_EffectsCF: NDogsCTR_EffectsCF NDogsCTR_EFCF; break;
            case SectionType_NDogsCTR_EffectsFS: NDogsCTR_EffectsFS NDogsCTR_EFFS; break;
            case SectionType_NDogsCTR_GoodsParam: NDogsCTR_GoodsParam NDogsCTR_GPRM; break;
            case SectionType_NDogsCTR_GoodsRParam: NDogsCTR_GoodsRParam NDogsCTR_GRPM; break;
            case SectionType_NDogsCTR_MiiVIS: NDogsCTR_MiiVIS NDogsCTR_MVIS; break;
            case SectionType_NDogsCTR_MiiNPC: NDogsCTR_MiiNPC NDogsCTR_MNPC; break;
            case SectionType_NDogsCTR_SharedTCM: NDogsCTR_SharedTCM NDogsCTR_STCM; break;
            default: FSeek(Header.sectionOffsets[i]+sizeof Header); SectionType UnknownEADSection; break;
            //default: SectionHeader UnknownEADSection; FSeek(Header.sectionOffsets[i]+sizeof Header); break;
        }
    }
} EADSectionedData<optimize=false>;