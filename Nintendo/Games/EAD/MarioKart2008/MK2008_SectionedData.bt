//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../../../LHR/Common.bt"

//https://mk3ds.com/index.php?title=KMP_(File_Format)
//https://wiki.tockdom.com/wiki/KMP_(File_Format)
//iirc avsys wiki had this too at least for MK7 but rip

//Shoutouts to course.0

typedef enum <uint32>
{
    SectionType_RevolutionKartMapData = 1380666692,
    SectionType_CTRDashMapData = 1145914435,
    SectionType_CTRDashDiv = 1111573571, //?
    SectionType_KartPoint = 1414550603,
    SectionType_EnemyPoint = 1414549061,
    SectionType_EnemyPath = 1213222469,
    SectionType_ItemPoint = 1414550601,
    SectionType_ItemPath = 1213224009,
    SectionType_CheckPoint = 1414548291,
    SectionType_CheckPointPath = 1213221699,
    SectionType_GlobalObject = 1245859655,
    SectionType_PointInformation = 1230262096,
    SectionType_Area = 1095062081,
    SectionType_Camera = 1162690883,
    SectionType_JugemPoint = 1414547274,
    SectionType_CannonPoint = 1414549059,
    SectionType_MissionSuccessPoint = 1414550349,
    SectionType_StageInfo = 1229411411,
    SectionType_CORS = 1397903171, //CTR
    SectionType_GliderPoint = 1414548551, //CTR
    SectionType_GliderPath = 1213221959, //CTR
    SectionType_Shape = 1346455635, //CTR
} SectionType;

typedef enum <byte>
{
    NormalCheckPoint = -1,
    CheckPointType_LapCountTrigger,
} CheckPointType;

typedef struct SectionHeader
{
    SectionType magic;
    if (Header.magic == SectionType_CTRDashMapData || Header.magic == SectionType_CTRDashDiv)
    {
        LittleEndian();
    }
    uint16 entries;
    uint16 other;
};

typedef struct KartPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 pos;
            Vector3_F32 start;
            uint16 playerIndex;
            uint16 pad;
        } KartPointEntry[h.entries];
    }
};

typedef struct EnemyPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 enemyPos;
            float start;
            uint16 pad[4]; //?
        } EnemyPointEntry[h.entries];
    }
};

typedef struct EnemyPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            if (Header.magic == SectionType_CTRDashMapData)
            {
                uint16 pointStart;
                uint16 pointLen;
                int16 prevGroup[16]; //16 previous enemy points
                int16 nextGroup[16]; //16 next enemy points
                uint32 bitFlag; //?
            }
            else
            {
                ubyte pointStart;
                ubyte pointLen;
                byte prevGroup[6]; //6 previous enemy points
                byte nextGroup[6]; //6 next enemy points
                ushort bitFlag;
            }
        } EnemyPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct ItemPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 itemPos;
            float bb;
            uint16 setting1;
            uint16 setting2; //Two u16s compared to MK7, being a u32, assuming since the header size is the same across both
        } ItemPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct ItemPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            if (Header.magic == SectionType_CTRDashMapData)
            {
                uint16 pointStart;
                uint16 pointLen;
                int16 prevGroup[6]; //6 previous item points
                int16 nextGroup[6]; //6 next item points
            }
            else
            {
                ubyte pointStart;
                ubyte pointLen;
                byte prevGroup[6]; //6 previous item points
                byte nextGroup[6]; //6 next item points
                uint16 pad;
            }
        } ItemPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct CheckPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector2_F32 leftPoint;
            Vector2_F32 rightPoint;
            byte respawnID;
            CheckPointType checkPointType;
            byte prevCheckPoint;
            byte nextCheckPoint;
            if (Header.magic == SectionType_CTRDashMapData)
            {
                byte unk[4];
            }
        } CheckPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct CheckPointPath
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            ubyte pointStart;
            ubyte pointLen;
            byte prevGroup[6]; //6 previous checkpoints
            byte nextGroup[6]; //6 next checkpoints
            uint16 pad; //Padding in MKW so assuming padding
        } CheckPointPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct GlobalObject
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint16 objectID;
            uint16 pad; //Padding in MKW so assuming padding
            Vector3_F32 pos;
            Vector3_F32 rot;
            Vector3_F32 scl;
            uint16 route;
            uint16 setting[8];
            uint16 presenceFlags;
            if (Header.magic == SectionType_CTRDashMapData)
            {
                byte unk[4];
            }
        } GlobalObjectEntry[h.entries]<optimize=false>;
    }
};

typedef struct PointInformation
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            uint16 points;
            byte setting1;
            byte setting2;
            struct
            {
                Vector3_F32 pos;
                uint16 routePointSetting;
                uint16 additionalSetting;
            } PointEntry[points];
        } PointInformationEntry[h.entries]<optimize=false>;
    }
};

typedef struct Area
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte shape;
            byte type;
            byte cameraIdx;
            byte priority;
            Vector3_F32 pos;
            Vector3_F32 rot;
            Vector3_F32 scl;
            uint16 setting1;
            uint16 setting2;
            byte routeID;
            byte enemyPointID;
            uint16 pad;
        } AreaEntry[h.entries]<optimize=false>;
    }
};

typedef struct Camera
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte type;
            byte nextCameraIdx;
            byte shake;
            byte route;
            uint16 cameraPointVel;
            uint16 zoomVel;
            uint16 viewPointVel;
            byte startFlag;
            byte movieFlag;
            Vector3_F32 pos;
            Vector3_F32 rot;
            float zoomStart;
            float zoomEnd;
            Vector3_F32 viewPointStartVec;
            Vector3_F32 viewPointDestVec;
            float activeTime;
        } CameraEntry[h.entries]<optimize=false>;
    }
};

typedef struct JugemPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 respawn;
            Vector3_F32 direction;
            uint16 respawnPosID;
            int16 extraFlag;
        } JugemPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct CannonPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 dest;
            Vector3_F32 direction;
            uint16 id;
            int16 shootEffect;
        } CannonPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct MissionSuccessPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 dest;
            Vector3_F32 direction;
            uint16 id;
            uint16 unk; //Effect, unused, looks similar to cannon point so assuming?
        } MissionSuccessPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct StageInfo
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            byte laps;
            byte polePos;
            byte normalDist;
            byte lensFlare;
            uint32 lensFlareColor;
            byte flareTrans;
            uint16 pad;
            byte pad2;
        } StageInfoEntry[h.entries]<optimize=false>;
    }
};

typedef struct CORSSection
{
    SectionHeader h; //Unused
};

typedef struct GliderPoint
{
    SectionHeader h;
    if (h.entries != 0)
    {
        struct
        {
            Vector3_F32 pos;
            float scale;
            uint32 unk[2];
        } GliderPointEntry[h.entries]<optimize=false>;
    }
};

typedef struct GliderPath
{
    SectionHeader h; //Unused
    if (h.entries != 0)
    {
        struct
        {
            byte pointStart;
            byte pointEnd;
            byte prevGroups[6];
            byte nextGroups[6];
            uint32 unk[2];
        } GliderPathEntry[h.entries]<optimize=false>;
    }
};

typedef struct Shape
{
    SectionHeader h; //Unused
    if (h.entries != 0)
    {
        struct
        {
            SectionHeader sh; //STRM
            Vector4_F32 v3f[sh.entries];
        } STRMEntry[h.entries]<optimize=false>;
    }
};

struct
{
    struct
    {
        BigEndian();
        SectionType magic;
        if (magic == SectionType_CTRDashMapData || magic == SectionType_CTRDashDiv) //Revolution Kart Map Data
        {
            LittleEndian();
        }
        uint32 fSize;
        uint16 sections;
        uint16 hLen;
        uint32 version;
        if (magic != SectionType_CTRDashDiv)
        {
            uint32 sectionOffsets[sections]; //Kart Map Data only
        }
        //Lazy so shape will error for now
    } Header;
    for (i; i < Header.sections; i++)
    {
        BigEndian();
        switch (ReadInt())
        {
            case SectionType_KartPoint: KartPoint KTPT; break;
            case SectionType_EnemyPoint: EnemyPoint ENPT; break;
            case SectionType_EnemyPath: EnemyPath ENPH; break;
            case SectionType_ItemPoint: ItemPoint ITPT; break;
            case SectionType_ItemPath: ItemPath ITPH; break;
            case SectionType_CheckPoint: CheckPoint CKPT; break;
            case SectionType_CheckPointPath: CheckPointPath CKPH; break;
            case SectionType_GlobalObject: GlobalObject GOBJ; break;
            case SectionType_PointInformation: PointInformation POTI; break;
            case SectionType_Area: Area AREA; break;
            case SectionType_Camera: Camera CAME; break;
            case SectionType_JugemPoint: JugemPoint JGPT; break;
            case SectionType_CannonPoint: CannonPoint CNPT; break;
            case SectionType_MissionSuccessPoint: MissionSuccessPoint MSPT; break;
            case SectionType_StageInfo: StageInfo STGI; break;
            case SectionType_CORS: CORSSection CORS; break; //CTR
            case SectionType_GliderPoint: GliderPoint GLPT; break; //CTR
            case SectionType_GliderPath: GliderPath GLPH; break; //CTR
            case SectionType_Shape: Shape SHAP; break; //CTR
        }
    }
} MarioKart2008SectionedData<optimize=false>;