//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: BZEngEntity.bt
//   Authors: LHR
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../Standard/CommonBin.bt"
#include "BezEngineStandard.bt"
#include "BezEngineComponents.bt"

typedef struct StringPoolTMP
    {
        //FSkip(-4);
        N_CommonBlockHdr_4Block STRPoolHdr;
        //int32 pad;
        int64 StrCnt;
        for( i2 = 0; i2 < StrCnt; i2++ )
        {
            struct String
            {
                int16 bSize;
                char theString[bSize];
                //byte nullb[2]; //todo figure out how to check
                //            |
                //            |
                //          \   /
                //           \ / :)
                for( i = 0; i < 99; i++ )
                {
                    struct PaddingChecker
                    {
                        byte dmy;
                        if (dmy == 0x00)
                        {
                            //FSkip(1);
                            //break;
                        }
                        else
                        {
                            break;
                        }
                    } padChk<hidden = true>;
                    if (padChk.dmy != 0x00)
                    {
                        FSkip(-1);
                        break;
                    }
                }
            } strings;
        }
        Printf("Padding has been skipped.\n");
        //int32 nullb2; todo figure out how to check
        //FSeek(hdr.RLTOffst); //RLT IS UNNECESSARY
        //byte d[1];
    } ;

local uint isNewEnty <hidden = true> = 0;

//local uint i <hidden = true> = 0;

local uint i2 <hidden = true> = 0;

local uint i3 <hidden = true> = 0;

local uint i4 <hidden = true> = 0;

local int terminateStrTblDetection <hidden = true> = 0;

//local int terminateEntyDetection <hidden = true> = 0;

typedef enum <byte>
{
    IsNotStatic = 0x0,
    IsStatic = 0x1,
    IsNotStatic_GlobalLighting = 0x2,
    IsStatic_GlobalLighting = 0x3,
} isStatic;

//typedef enum <byte>
//{
    //HasNoScripts,
    //HasScripts,
//} hasScripts;

/*typedef enum <int32>
{
    CC_ComTransform = 0,
    CC_ComRenderer = 1,
    CC_ComCollision = 2,
    CC_ComCharacterCollision = 3,
    //if (isOldBzEng)
    //{
        //CC_ComGroup_V1 = 4,
    //}
    //else
    //{
        CC_ComHitCollision = 4,
    //}
    CC_ComMapPath_V1 = 5,
    CC_ComPhysics2d = 6,
    CC_ComGroup = 7,
    CC_ComMapPath = 8,
    CC_ComLightEmitter = 9,
    CC_ComAudioEmitter = 10,
    CC_ComParticleFxEmitter = 11,
    CC_ComGuiLayout = 12,
    CC_ComUiWidget = 13,
    CC_ComProperty = 14,
    CC_ComGlobalLighting = 15,
    CC_ComMapLighting = 16,
    CC_ComCharacter = 17,
    CC_ComCamera = 18,
    CC_ComCloth = 19,
    CC_ComSprite = 20,
    CC_ComFxTrigger = 21,
    CC_ComTransform2d = 22,
    CC_ComCollision2d = 23,
} componentCategory;*/

if (isNewEnty)
{
    typedef enum <int32>
    {
        CC_ComTransform,
        CC_ComRenderer,
        CC_ComCollision,
        CC_ComCharacterCollision,
        CC_ComHitCollision,
        CC_ComPhysics,
        CC_ComPhysics2d,
        CC_ComGroup,
        CC_ComMapPath,
        CC_ComLightEmitter,
        CC_ComAudioEmitter,
        CC_ComParticleFxEmitter,
        CC_ComGuiLayout,
        CC_ComUiWidget,
        CC_ComProperty,
        CC_ComGlobalLighting,
        CC_ComMapLighting,
        CC_ComCharacter,
        CC_ComCamera,
        CC_ComCloth,
        CC_ComSprite,
        CC_ComFxTrigger,
        CC_ComTransform2d,
        CC_ComCollision2d
    } componentCategory;
}

else 
{
    typedef enum <int32>
    {
        CC_ComTransform_V1,
        CC_ComRenderer_V1,
        CC_ComCollision_V1,
        CC_ComCharacterCollision_V1,
        CC_ComGroup_V1,
        CC_ComMapPath_V1 = 5,
        CC_ComPhysics2d_V1,
        //CC_ComGroup_V1,
        //CC_ComLightEmitter_V1,
        //CC_ComAudioEmitter_V1,
        //CC_ComParticleFxEmitter_V1,
        //CC_ComGuiLayout_V1,
        //CC_ComUiWidget_V1,
        //CC_ComProperty_V1,
        CC_ComGlobalLighting_V1 = 10,
        CC_ComMapLighting_V1,
        CC_ComCharacter_V1,
        CC_ComCamera_V1,
        CC_ComCloth_V1,
        CC_ComSprite_V1,
        CC_ComFxTrigger_V1,
        CC_ComTransform2d_V1,
        CC_ComCollision2d_V1
    } componentCategoryV1;
}

LittleEndian();

typedef struct BezelEngineEntity
{
    //terminateEntyDetection = 0;
    N_CommonBlockHdr_4Block EntityBlock;
    byte entyGUID[16];
    int64 entyNameOffst;
    //FSeek(entyNameOffst);
    //int16 bSize;
    //char str[bSize];
    //FSeek(entyNameOffst)
    int64 prmOffTbl;
    if (prmOffTbl == 0)
    {
        int64 dbytes[2];
        FSkip(3);
        isStatic isEntityStatic;
        int32 dmy2;
        break; //Terminate Entity detection as no other params are found
    }
    else
    {       
        int64 dmy2;
        int64 prmTblOffstTblInV1;
        byte componentCnt;
        byte scriptCnt;
        byte stringCntBeforePrmInV1;
        isStatic IsEntityStatic;
        int32 dmy4;
        int64 prmTblOffsts[componentCnt];
        //if (hasPlatCookStr)
        //{
            if (stringCntBeforePrmInV1 > 0)
            {
                int64 stringBeforeParamsOffst[stringCntBeforePrmInV1];
            }
            //int32 dmy;
            //int64 unk[2];
        //}
        for (i = 0; i < scriptCnt; i++)
        {
            struct ScriptRefTbl
            {
                int64 ScriptFilePathOffset;
                int64 ScriptParamTblSize;
                int64 ScriptParamCnt;
            } srt;
        }
        for (i = 0; i < componentCnt; i++)
        {
            struct ParamTable
            {
                if (isNewEnty)
                {
                    componentCategory ComponentCategory;
                }
                else
                {
                    componentCategoryV1 ComponentCategory;
                }
                if (ComponentCategory == CC_ComLightEmitter)
                {
                    NB_ComLightEmitterTbl clet;
                }
                if (ComponentCategory == CC_ComAudioEmitter)
                {
                    if (entityHdr.version.major > 5)
                    {
                        NB_ComAudioEmitterTbl caet;
                    }
                }
                if (ComponentCategory == CC_ComParticleFxEmitter)
                {
                    NB_ComParticleFxEmitterTbl cpfxe;
                }
                if (ComponentCategory == CC_ComGuiLayout && isNewEnty)
                {
                    NB_ComGuiLayoutTbl cguilt;
                }
                if (ComponentCategory == CC_ComUiWidget)
                {
                    NB_ComUiWidgetTbl cuiwt;
                }
                if (ComponentCategory == CC_ComProperty)
                {
                    NB_ComPropertyTbl cproptbl;
                }
                if (ComponentCategory == CC_ComTransform)
                {
                    NB_ComTransformTbl ct;
                }
                if (ComponentCategory == CC_ComTransform2d)
                {
                    NB_ComTransformTbl2D ct2d;
                }
                if (ComponentCategory == CC_ComCharacterCollision)
                {
                    NB_ComCharacterCollision cclsn;
                }
                if (ComponentCategory == 4 && isNewEnty)
                {
                    NB_ComHitCollision chc;
                }
                if (ComponentCategory == CC_ComRenderer || ComponentCategory == CC_ComRenderer_V1)
                {
                    NB_ComRenderer crdr; //Hell
                }
                if (ComponentCategory == CC_ComGroup || ComponentCategory == CC_ComGroup_V1)
                {
                    //if (entityHdr.version.major > 5)
                    //{
                        //break;
                    //}
                    NB_ComGroupTbl cg;
                }
                if (ComponentCategory == CC_ComCollision)
                {
                    NB_ComCollisionTbl cc;
                }
                if (ComponentCategory == CC_ComCollision2d)
                {
                    NB_ComCollision2dTbl cc2d;
                }
                if (ComponentCategory == CC_ComPhysics2d)
                {
                    NB_ComPhysics2d cphy2d;
                }
                if (ComponentCategory == CC_ComPhysics)
                {
                    if (entityHdr.version.major > 5)
                    {
                        NB_ComPhysics cphy;
                    }
                    /*else
                    {
                        struct ComUnk5 //HELP
                        {
                            int32 unk;
                            int64 PrmTblOffst; //Some Prm Tbl Offst?
                            int64 RefEntyTblCnt;
                            int64 EntityOffst;
                            int64 someOtherOff;
                            int64 unk2;
                            int64 SubEntityOffst;
                            int64 someOtherOff2;
                            int64 unk3;
                            struct MapPosVertex
                            {
                                float Position[3];
                            } mpv[4];
                            //float Position2[3];
                            //float Position3[3];
                            //float Position4[3];
                            int32 dmy;
                            struct MapPosVertex2
                            {
                                float Position[3];
                            } mpv2[2];
                            struct ControlPoint
                            {
                                float Position[3];
                            } cpnt[2];
                            //float Position6[3];
                            int32 unk4;
                            int64 RefEntyPrmOffst;
                            int32 what[2];
                            int64 unknown;
                            //isTrigger IsTrigger;
                            //NB_CollisionLayer CollisionLayer;
                            //NB_CollisionQuality CollisionQuality;
                            //byte dbytes[5];
                        } c5;
                    }*/
                }
                if (ComponentCategory == CC_ComMapPath || ComponentCategory == CC_ComMapPath_V1)
                {
                    //TODO REWRITE THIS, MESSY AF
                    NB_ComMapPath cmp; //?
                }
                if (ComponentCategory == CC_ComGlobalLighting || ComponentCategory == CC_ComGlobalLighting_V1)
                {
                    NB_ComGlobalLightingTbl cgl;
                }
                if (ComponentCategory == CC_ComMapLighting)
                {
                    NB_ComMapLightingTbl cml;
                }
                if (ComponentCategory == CC_ComCamera)
                {
                    NB_ComCameraTbl ccmratl;
                }
                if (ComponentCategory == CC_ComCloth)
                {
                    NB_ComClothTbl ccltht;
                }
                if (ComponentCategory == CC_ComSprite)
                {
                    NB_ComSpriteTbl cccst;
                }
                if (ComponentCategory == CC_ComFxTrigger)
                {
                    NB_ComFxTriggerTbl cfxtt;
                }
                if (ComponentCategory == CC_ComCharacter || ComponentCategory == CC_ComCharacter_V1)
                {
                    NB_ComCharacterTbl cchart;
                }
            } prt;
        }
        if (scriptCnt != 0)
        {
            char BlockChecker[4]<hidden = true>;
            FSkip(-4);
            if (BlockChecker == "ENTY" || BlockChecker == "_STR")
            {
                //terminateEntyDetection = 1;
                //FSkip(-4);
                //Printf("Entity ended early.");
                break;
                
            }
            //if (srt.ScriptParamTblSize != 0)
            //{
                
                for (i = 0; i < scriptCnt; i++)
                {
                    struct ScriptParamTbl
                    {
                        
                        //int64 prmTblOffst[2];
                        //int64 unk;
                        //for (i = 0; i < 2; i++)
                        //{
                            struct ScriptParam
                            {
                                int64 ScriptPrmTblOffst[srt.ScriptParamCnt];
                                NB_ScriptParamType ScriptParamType;
                                
                                if (ScriptParamType == ScriptParamType_Int)
                                {
                                    struct EntityIntParam
                                    {
                                        int64 ParamKeyOffst[2];
                                    } eip;
                                }
                                
                                if (ScriptParamType == ScriptParamType_Entity)
                                {
                                    struct EntityScriptParam
                                    {
                                        int64 ParamKeyOffst;
                                        byte  scriptGUID[16];
                                    } esp;
                                }
                                if (ScriptParamType == ScriptParamType_Float)
                                {
                                    struct EntityFloatParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        float Value;
                                        int32 dmy;
                                    } efp;
                                }
                                if (ScriptParamType == ScriptParamType_String)
                                {
                                    struct EntityStringParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        int64 Value;
                                        //int32 dmy;
                                    } estrp;
                                }
                                if (ScriptParamType == ScriptParamType_ScriptRef)
                                {
                                    struct EntityScriptRefParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        int64 Value;
                                        //int32 dmy;
                                    } estrp;
                                }
                                //int64 ScriptFilePathOffst;
                                //byte  scriptGUID[16];
                            } scriptPrm;
                        //}
                    } sptbl;
                //}
            }
        }
        //WIP
        /*char BlockChecker2[4]<hidden = true>;
        FSkip(-4);
        if (BlockChecker2 == "ENTY" || BlockChecker2 == "_STR")
        {
            //terminateEntyDetection = 1;
            //FSkip(-4);
            //Printf("Entity ended early.");
            break;        
        }
        else
        {
            FSkip(72); //idk
        }*/
    }   
};

struct EntityFile
{
    N_CommonBinHdr entityHdr<bgcolor = cBlue>;
    struct Content
    {
        int64 entityChunkOffst<bgcolor = cYellow>;
        int64 unk<bgcolor = cYellow>;
        int64 entityBlockOffst<bgcolor = cYellow>;
        BezelEngineEntity theMainEntity<bgcolor = cGreen>;
        for (i = 0; i < 99; i++)
        {
            struct TheNextBlock
            {
                char nextBlockType[4]<hidden=true>;
                if (nextBlockType == "ENTY")
                {
                    FSkip(-4);
                    struct NextEnty
                    {
                        BezelEngineEntity theNextEntity<bgcolor = cBlue>;
                    } nEnty;
                }
                //FSkip(4);
                if (nextBlockType == "_STR")
                {
                    FSkip(-4);
                    StringPoolTMP theStringPool<bgcolor = cPurple>;
                    terminateStrTblDetection = 1;
                }
                if (terminateStrTblDetection == 1)
                {
                    N_RelocationTable theRelocTbl<bgcolor=cRed>;
                }
            } nb;
            if (terminateStrTblDetection == 1)
            {
                break;
            }
        } //tnb;
    } content<comment="Bezel Entity Bin Content">;
} entity<comment="Binary NintendoWare Bezel Engine Entity">;