//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: BZEngEntity.bt
//   Authors: LHR
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//TODO: REWRITE COMMAPGROUP PLEASE

typedef struct RelocTbl
    {
        char RLTHdr[4];
        int32 memAddress;
        int32 sections;
        int32 pad;
        if (sections >= 1)
        {
            struct Section
            {
                int64 memAddress;
                int32 fOff;
                int32 fSize;
                int32 idxfirst;
                int32 relocs;
            } section[sections];
            struct Reclocations
            {
                int32 fOff;
                int16 chunks;
                byte relocwords;
                byte nonrelocwords;
            } reloc[section.relocs];
        }
        else
        {
            byte d[52];
        }
        //int64 dmy;
    } reloc;

typedef struct StringTable
    {
        //FSkip(-4);
        char STRTblHdr[4];
        int32 null;
        int64 bSize;
        //int32 pad;
        int64 StrCnt;
        for( i2 = 0; i2 < StrCnt; i2++ )
        {
            struct String
            {
                int16 bSize;
                char theString[bSize];
                //byte nullb[2]; //todo figure out how to check
                //            |
                //            |
                //          \   /
                //           \ / :)
                for( i = 0; i < 99; i++ )
                {
                    struct PaddingChecker
                    {
                        byte dmy;
                        if (dmy == 0x00)
                        {
                            //FSkip(1);
                            //break;
                        }
                        else
                        {
                            break;
                        }
                    } padChk<hidden = true>;
                    if (padChk.dmy != 0x00)
                    {
                        FSkip(-1);
                        break;
                    }
                }
            } strings;
        }
        Printf("Padding has been skipped.\n");
        //int32 nullb2; todo figure out how to check
        //FSeek(hdr.RLTOffst); //RLT IS UNNECESSARY
        //byte d[1];
    } strTbl;

typedef struct EntityName
{
    int16 bSize;
    char  theString[bSize];
} eName;

local uint isNewEnty <hidden = true> = 0;

local uint i <hidden = true> = 0;

local uint i2 <hidden = true> = 0;

local uint i3 <hidden = true> = 0;

local uint i4 <hidden = true> = 0;

local int terminateStrTblDetection <hidden = true> = 0;

//local int terminateEntyDetection <hidden = true> = 0;

typedef enum <byte>
{
    IsNotStatic = 0x0,
    IsStatic = 0x1,
    IsNotStatic_GlobalLighting = 0x2,
    IsStatic_GlobalLighting = 0x3,
} isStatic;

typedef enum <byte>
{
    CCPT_PerspectiveFovy,
    CCPT_PerspectiveFrustum,
    CCPT_PerspectiveLighty,
    CCPT_Orthographic,
    CCPT_Custom
} comCameraProjectionType;

typedef enum <byte>
{
    LT_Directional,
    LT_Point,
    LT_Spot
} lightType;

typedef enum <int16>
{
    ASOT_MilliSeconds,
    ASOT_Tick,
    ASOT_Sample
} audioStartOffsetType;

typedef enum <int16>
{
    BBT_None,
    BBT_AllAxis,
    BBT_AxisXZ
} billboardType;

typedef enum <byte>
{
    Disabled = 0x00,
    Submersible = 0x01,
    Submerged = 0x02,
} underWaterRenderingMode;

//typedef enum <byte>
//{
    //HasNoScripts,
    //HasScripts,
//} hasScripts;

typedef enum <byte>
{
    False = 0x0,
    True = 0x1,
} boolChecker;

typedef enum <byte>
{
    BTC_Auto = 0x0,
    BTC_Always = 0x1,
    BTC_Never = 0x2,
} bakeTargetCondition;

/*typedef enum <int32>
{
    CC_ComTransform = 0,
    CC_ComRenderer = 1,
    CC_ComCollision = 2,
    CC_ComCharacterCollision = 3,
    //if (isOldBzEng)
    //{
        //CC_ComGroup_V1 = 4,
    //}
    //else
    //{
        CC_ComHitCollision = 4,
    //}
    CC_ComMapPath_V1 = 5,
    CC_ComPhysics2d = 6,
    CC_ComGroup = 7,
    CC_ComMapPath = 8,
    CC_ComLightEmitter = 9,
    CC_ComAudioEmitter = 10,
    CC_ComParticleFxEmitter = 11,
    CC_ComGuiLayout = 12,
    CC_ComUiWidget = 13,
    CC_ComProperty = 14,
    CC_ComGlobalLighting = 15,
    CC_ComMapLighting = 16,
    CC_ComCharacter = 17,
    CC_ComCamera = 18,
    CC_ComCloth = 19,
    CC_ComSprite = 20,
    CC_ComFxTrigger = 21,
    CC_ComTransform2d = 22,
    CC_ComCollision2d = 23,
} componentCategory;*/

if (isNewEnty)
{
    typedef enum <int32>
    {
        CC_ComTransform,
        CC_ComRenderer,
        CC_ComCollision,
        CC_ComCharacterCollision,
        CC_ComHitCollision,
        CC_ComPhysics,
        CC_ComPhysics2d,
        CC_ComGroup,
        CC_ComMapPath,
        CC_ComLightEmitter,
        CC_ComAudioEmitter,
        CC_ComParticleFxEmitter,
        CC_ComGuiLayout,
        CC_ComUiWidget,
        CC_ComProperty,
        CC_ComGlobalLighting,
        CC_ComMapLighting,
        CC_ComCharacter,
        CC_ComCamera,
        CC_ComCloth,
        CC_ComSprite,
        CC_ComFxTrigger,
        CC_ComTransform2d,
        CC_ComCollision2d
    } componentCategory;
}

else 
{
    typedef enum <int32>
    {
        CC_ComTransform_V1,
        CC_ComRenderer_V1,
        CC_ComCollision_V1,
        CC_ComCharacterCollision_V1,
        CC_ComGroup_V1,
        CC_ComMapPath_V1 = 5,
        CC_ComPhysics2d_V1,
        //CC_ComGroup_V1,
        //CC_ComLightEmitter_V1,
        //CC_ComAudioEmitter_V1,
        //CC_ComParticleFxEmitter_V1,
        //CC_ComGuiLayout_V1,
        //CC_ComUiWidget_V1,
        //CC_ComProperty_V1,
        CC_ComGlobalLighting_V1 = 10,
        CC_ComMapLighting_V1,
        CC_ComCharacter_V1,
        CC_ComCamera_V1,
        CC_ComCloth_V1,
        CC_ComSprite_V1,
        CC_ComFxTrigger_V1,
        CC_ComTransform2d_V1,
        CC_ComCollision2d_V1
    } componentCategoryV1;
}

typedef enum <int32>
{
    CLSNShapeType_Box = 0,
    CLSNShapeType_Sphere = 1,
    CLSNShapeType_Capsule = 2,
} collisionShapeType;

typedef enum <int64>
{
    CLSN2dShapeType_Box2d,
    CLSN2dShapeType_Circle2d,
    CLSN2dShapeType_CornerClippedBox2d,
    CLSN2dShapeType_OpenBoxEdge2d
} collisionShapeType2d;

typedef enum <int32>
{
    HitCLSNShapeType_Attack = 0,
    HitCLSNShapeType_Damage = 1,
} hitCollisionType;

typedef enum <int64>
{
    ScriptParamType_Int = 0,
    ScriptParamType_Float = 1,
    ScriptParamType_Bool = 2,
    ScriptParamType_String = 3,
    //ScriptParamType_Entity,
    ScriptParamType_Entity = 5,
    ScriptParamType_ScriptRef = 6,
} scriptParamType;

typedef enum <byte>
{
    SPRTBlendMode_None,
    SPRTBlendMode_AlphaBlend,
    SPRTBlendMode_Additive,
    SPRTBlendMode_Subtractive
} spriteBlendMode;

typedef enum <int64>
{
    ComPropertyValueType_Int,
    ComPropertyValueType_Float,
    ComPropertyValueType_Bool,
    ComPropertyValueType_String,
    ComPropertyValueType_Vector3,
    ComPropertyValueType_Matrix43
} comPropertyValueType;

typedef enum <int32>
{
    CL_All,
    CL_None,
    CL_Default,
    CL_Character,
    CL_Static,
    CL_Debris,
    CL_HitCollisionAttack,
    CL_HitCollisionDamage,
    CL_PhysicalAnimation,
    CL_User1,
    CL_User2,
    CL_User3,
    CL_User4,
    CL_User5,
    CL_User6,
    CL_User7,
    CL_User8,
} collisionLayer;

typedef enum <int32>
{
    CL2d_All,
    CL2d_None,
    CL2d_Default,
    CL2d_Static,
    CL2d_Debris,
    CL2d_User1,
    CL2d_User2,
    CL2d_User3,
    CL2d_User4,
    CL2d_User5,
    CL2d_User6,
    CL2d_User7,
    CL2d_User8,
} collisionLayer2d;

typedef enum <byte>
{
    CQ_Invalid,
    CQ_Debris,
    CQ_RobustDebris,
    CQ_Moving,
    CQ_Critical,
    CQ_Bullet,
} collisionQuality;

typedef enum <byte>
{
    CQ2d_Invalid,
    CQ2d_Moving,
    CQ2d_Bullet,
} collisionQuality2d;

LittleEndian();

typedef struct EntityContent
{
    //terminateEntyDetection = 0;
    char ENTY[4];
    int32 NextBlockOffst;
    int64 nboAgain;
    byte entyGUID[16];
    int64 entyNameOffst;
    //FSeek(entyNameOffst);
    //int16 bSize;
    //char str[bSize];
    //FSeek(entyNameOffst)
    int64 prmOffTbl;
    if (prmOffTbl == 0)
    {
        int64 dbytes[2];
        FSkip(3);
        isStatic isEntityStatic;
        int32 dmy2;
        break; //Terminate Entity detection as no other params are found
    }
    else
    {       
        int64 dmy2;
        int64 prmTblOffstTblInV1;
        byte componentCnt;
        byte scriptCnt;
        byte stringCntBeforePrmInV1;
        boolChecker IsEntityStatic;
        int32 dmy4;
        int64 prmTblOffsts[componentCnt];
        //if (hasPlatCookStr)
        //{
            int64 stringBeforeParamsOffst[stringCntBeforePrmInV1];
            //int32 dmy;
            //int64 unk[2];
        //}
        for (i = 0; i < scriptCnt; i++)
        {
            struct ScriptRefTbl
            {
                int64 ScriptFilePathOffset;
                int64 ScriptParamTblSize;
                int64 ScriptParamCnt;
            } srt;
        }
        for (i = 0; i < componentCnt; i++)
        {
            struct ParamTable
            {
                if (isNewEnty)
                {
                    componentCategory ComponentCategory;
                }
                else
                {
                    componentCategoryV1 ComponentCategory;
                }
                if (ComponentCategory == CC_ComLightEmitter)
                {
                    struct ComLightEmitterTbl
                    {
                        float Range;
                        float InnerSpotAngle;
                        float OuterSpotAngle;
                        float Color[3];
                        float Intensity;
                        float SourceRadius;
                        float AttentuationPower;
                        float Specular[3];
                        FSkip(12);
                        float SpotFallOff;
                        lightType LightType;
                        byte LightFilePathCnt;
                        boolChecker DirectLightBakeMode;
                        byte dmy;
                        if (LightFilePathCnt != 0)
                        {
                            struct LightFilePath
                            {
                                int64 dmy;
                                {
                                    struct LightFileTbl
                                    {
                                        int64 strtbloff;
                                    } lft[LightFilePathCnt];
                                }
                            } lfp;
                        }
                    } clet;
                }
                if (ComponentCategory == CC_ComAudioEmitter)
                {
                    if (hdr.theHdr.major > 5)
                    {
                        struct ComAudioEmitterTbl // PROBABLY PERFECT
                        {
                            FSkip(4);
                            int64 AssetFilePathOff;
                            int64 AudioNameOff;
                            float Volume;
                            float Pitch;
                            float Pan;
                            float FadeInSecond;
                            float FadeOutSecond;
                            audioStartOffsetType AudioStartOffsetType;
                            int16 StartOffset;
                        } caet;
                    }
                }
                if (ComponentCategory == CC_ComParticleFxEmitter)
                {
                    struct ComParticleFxEmitterTbl
                    {
                        FSkip(4);
                        int64 ParticleFxAssetPathOff;
                        int64 EmitterSetNameOff;
                        float MultiplyColor[4];
                        float ParticleGlobalScale[3];
                        float ParticleEmissionScale[3];
                        float EmitterVolumeScale[3];
                        boolChecker IsVisible;
                        byte GroupId;
                        billboardType BillboardType;
                    } cpfxe;
                }
                if (ComponentCategory == CC_ComGuiLayout && isNewEnty)
                {
                    struct ComGuiLayoutTbl
                    {
                        FSkip(4);
                        int64 LayoutArchivePathOff;
                        int64 LayoutNameOff;
                        int64 someOff;
                        int64 LayoutNameOffAgain;
                        FSkip(40);
                        if (LayoutNameOff == LayoutNameOffAgain)
                        {
                            local boolChecker isViewportScissorInfoEnabled = 1;
                        }
                        else
                        {
                            local boolChecker isViewportScissorInfoEnabled = 0;
                        }
                        struct ViewportScissorInfo
                        {
                            int32 ViewportWidth;
                            int32 ViewportHeight;
                            int32 ViewportOrigin[2];
                            int32 ScissorWidth;
                            int32 ScissorHeight;
                            int32 ScissorOrigin[2];
                        } vsi;
                        FSkip(40);
                        int64 StrTblOff;
                    } cguilt;
                }
                if (ComponentCategory == CC_ComUiWidget)
                {
                    struct ComUiWidgetTbl
                    {
                        FSkip(4);
                        int64 HudNameOff;
                        int32 unk;
                        float Position[3];
                        float Rotate[3];
                        float Scale[2];
                        boolChecker IsVisible;
                        FSkip(3);
                    } cuiwt;
                }
                if (ComponentCategory == CC_ComProperty)
                {
                    struct ComPropertyTbl
                    {
                        FSkip(4);
                        int64 unk;
                        int64 kvpCount;
                        for (i = 0; i < kvpCount; i++)
                        {
                            struct KeyValuePair
                            {
                                int64 keyOff;
                                int64 ValueOff;
                                comPropertyValueType ComPropertyValueType;
                            } kvp;
                        }
                    } cproptbl;
                }
                if (ComponentCategory == CC_ComTransform)
                {
                    struct ComTransformTbl // PROBABLY PERFECT
                    {
                        float Translate[3];
                        float Rotate[3];
                        float possiblyDummy;
                        float Scale[3];
                        int32 dmy;
                    } ct;
                }
                if (ComponentCategory == CC_ComTransform2d)
                {
                    struct ComTransformTbl2D
                    {
                        float Scale[2];
                        float Translation[2];
                        float XYRotation[2];
                        int32 dmy;
                        float ZScale;
                        float Depth;
                        int64 end;
                    } ct2d;
                }
                if (ComponentCategory == CC_ComCharacterCollision)
                {
                    struct ComCharacterCollision
                    {
                        hitCollisionType HitCollisionType;
                        int64 clsnShapeOff;
                        struct CollisionShape
                        {
                            collisionShapeType CLSNShapeType;
                            int32 dmy;
                            int64 clsnTblOff;
                            struct CollisionTable
                            {
                                if (CLSNShapeType == CLSNShapeType_Box)
                                {
                                    float Size[3];
                                    byte d[20];
                                }
                                if (CLSNShapeType == CLSNShapeType_Sphere)
                                {
                                    byte dmy[24];
                                    float Radius;
                                    int32 end;
                                }
                                if (CLSNShapeType == CLSNShapeType_Capsule)
                                {
                                    byte dmy[16];
                                    float Radius;
                                    float Length;
                                    int64 end;
                                }
                            } ctbl;
                        } cshp;
                    } ccclsn;
                }
                if (ComponentCategory == 4 && isNewEnty)
                {
                    struct ComHitCollision //need fixes
                    {
	                    int32 nodeCntBeforeComp;
                        if (nodeCntBeforeComp == 0) //kill if CHC is empty
	                    {
			                FSkip(56);
                            break;
                        }
                        int64 offToTbl;
                        FSeek(offToTbl+8);
                        for( i = 0; i < nodeCntBeforeComp; i++ )
                        {
		                    struct ComHitColTbl
                            {
			                    int64 StrTblOffst;
                                /*if (StrTblOffst != StrTblOffst)
                                {
                                    FSkip(-8);
                                    int64 offstonoffst;
                                    int64 unk;
                                    FSkip(unk+8);
                                    break;
                                }*/
			                    int64 someOtherOff;
			                    if (someOtherOff != 0)
			                    {
				                    FSeek(someOtherOff-8); //skip cpad
			                    }
                                //if (someOtherOff == 40)
			                    //{
                                    //FSkip(-16);
				                    //FSeek(someOtherOff-8); //skip cpad
			                    //}
			                    else
			                    {
				                    int64 offstTo28;
				                    int64 unk;
				                    FSkip(-16);
				                    //if (nodeCntBeforeComp >= 2)
				                    //{
					                    //FSkip(unk+16);
				                    //}
				                    //else
				                    //{
					                    FSkip(unk+8);
				                    //}
			                    }
                            } chctbl;
                        }
                        struct FinalCHT
                        {
                            int64 unk;
                            int64 unk2;
                            FSkip(24);
                        } fcht;
                        FSkip(-8);
                    } chc;
                }
                if (ComponentCategory == CC_ComRenderer || ComponentCategory == CC_ComRenderer_V1)
                {
                    struct ComRenderer //Hell
                    {
                        FSkip(4);
                        int64 FPathOffst;
                        if (hdr.theHdr.major > 5)
                        {
                            int64 rootBoneNameOffst;
                        }
                        //float possiblyDummy;
                        float ScaleX;
                        float unknown[3];
                        //float Translate[3];
                        //float Scale[3];
                        float ScaleY;
                        float unk2;
                        float unk3[2];
                        float ScaleZ;
                        float Translate[3];
                        //boolChecker isCastShadow;
                        //boolChecker isRecieveShadow;
                        bakeTargetCondition bakeTarget;
                        byte ComRenderFlag; //Related to bools
                        //byte unknownFlag;
                        underWaterRenderingMode UnderWaterRenderingMode;
                        byte InterKineticCalcInterCnt;
                        float LightMapScale;
                        float InterKineticTolerance;
                        byte BoneRefMdlCnt;
                        byte SklRefMdlCnt;
                        byte MtlRefMdlCnt;
                        byte AnimRefMdlCnt;
                        byte prmCntForInterKineticConstraints;
                        byte prmCntForInterKineticAngleLimiters;
                        //int64 unknowni;
                        //int64 d[4];
                        FSkip(6);
                        //int64 strTblOff;
                        //int64 o[(BoneRefMdlCnt + SklRefMdlCnt + MtlRefMdlCnt + AnimRefMdlCnt) + 2];    
                        if (hdr.theHdr.major > 5)
                        {
                            if (BoneRefMdlCnt != 0)
                            {
                                int64 BoneRefFilePathOff;
                            }
                            else
                            {
                                FSkip(8);
                            }
                            if (SklRefMdlCnt != 0)
                            {
                                int64 SklRefFilePathOff;
                            }
                            else
                            {
                                FSkip(8);
                            }
                            if (MtlRefMdlCnt != 0)
                            {
                                int64 MtlRefFilePathOff;
                            }
                            else
                            {
                                FSkip(8);
                            }
                            if (AnimRefMdlCnt != 0)
                            {
                                int64 AnimRefFilePathOff;
                            }
                            else
                            {
                                FSkip(8);
                            }
                            char BlockChecker[4]<hidden = true>;
                            FSkip(-4);
                            if (BlockChecker == "ENTY" || BlockChecker == "_STR")
                            {
                                FSkip(-4);
                                break;
                            }
                            //int64 strTblOff[(BoneRefMdlCnt + SklRefMdlCnt + MtlRefMdlCnt + AnimRefMdlCnt) - 2];    
                            int64 unk;
                            int64 unk5;
                            if (unk5 != 0)
                            {
                                FSeek(unk5);
                            }
                            else
                            {   
                                break;
                                //int64 unkn2;
                            }
                            //int64 compilerCache[2];
                            int64 StrTblOffst;
                            if (unk5 != 0)
                            {
                                int64 CPad[14];
                            }
                            //else
                            //{
                                //int64 CPad[4];
                            //}
                            //int32 unk7;
                            //byte dmy[40];
                            //byte unknownBytes[384];
                            //int32 dmy;
                            //isHasPhysSim PhysSim;
                            //byte unk3[7];
                            //float unk4;
                            //float unk5;
                        }
                    } crdr;
                }
                if (ComponentCategory == CC_ComGroup || ComponentCategory == CC_ComGroup_V1)
                {
                    //if (hdr.theHdr.major > 5)
                    //{
                        //break;
                    //}
                    struct ComGroupTbl
                    {
                        //int64 nextEntyOffstTblOffst;
                        int32 dmy;
                        int64 nextEntyOffstTblOffst;
                        if (nextEntyOffstTblOffst == 0)
                        {
                            int64 pad; //assume its padding as no enty offst doesn't make sense
                            break;
                        }
                        int64 entyCnt;
                        int64 nextEntyOffst[entyCnt];
                    } cg;
                }
                if (ComponentCategory == CC_ComCollision)
                {
                    struct ComCollisionTbl
                    {
                        FSkip(4);
                        int64 strTblOffst; //Some Str Tbl Offst?
                        boolChecker IsTrigger;
                        collisionLayer CollisionLayer;
                        collisionQuality CollisionQuality;
                        if (hdr.theHdr.major >= 3)
                        {
                            FSkip(2);
                        }
                        else
                        {
                            FSkip(5);
                        }
                    } cc;
                }
                if (ComponentCategory == CC_ComCollision2d)
                {
                    struct ComCollision2dTbl
                    {
                        boolChecker IsTrigger;
                        collisionLayer2d CollisionLayer2d;
                        FSkip(-1);
                        float Offset[2];
                        float Friction;
                        float Restitution;
                        int64 clsnShape2dOff;
                        collisionShapeType2d CLSNShapeType2d;
                        //FSkip(4);
                        int64 clsnTbl2DOff;
                        FSeek(clsnTbl2DOff);
                        struct CollisionTable2d
                        {
                            if (CLSNShapeType2d == CLSN2dShapeType_Box2d)
                            {
                                struct Collision2dBox2D
                                {
                                    float HalfExtent[2];
                                    FSkip(40);
                                } cc2db2d;
                            }
                            if (CLSNShapeType2d == CLSN2dShapeType_Circle2d)
                            {
                                //FSkip(8);
                                struct Collision2dCircle2d
                                {
                                    float Radius;
                                    FSkip(36);
                                } cc2db2d;
                            }
                            if (CLSNShapeType2d == CLSN2dShapeType_CornerClippedBox2d)
                            {
                                //FSkip(8);
                                struct Collision2dCornerClippedBox2d //openboxedge2d is also this
                                {
                                    FSkip(8);
                                    float ClippingLength;
                                    FSkip(20);
                                } cc2dccb2d;
                            }
                        } ctbl2d;
                        //if (CLSNShapeType2d == Box2D)
                        //{
                        //}
                    } cc2d;
                }
                if (ComponentCategory == CC_ComPhysics2d)
                {
                    struct ComPhysics2d
                    {
                        float Density;
                        float GravityScale;
                        float LinearDamping;
                        float AngularDamping;
                        collisionQuality2d CollisionQuality2d;
                        boolChecker RotationFixed;
                        FSkip(2);
                    } cphy2d;
                }
                if (ComponentCategory == CC_ComPhysics)
                {
                    if (hdr.theHdr.major > 5)
                    {
                        struct ComPhysics
                        {
                            float Mass;
                            float StaticFriction;
                            float DynamicFriction;
                            float Restitution;
                            float LinearVelocityDamping;
                            float AngularVelocityDamping;
                            FSkip(4);
                        } cphy;
                    }
                    /*else
                    {
                        struct ComUnk5 //HELP
                        {
                            int32 unk;
                            int64 PrmTblOffst; //Some Prm Tbl Offst?
                            int64 RefEntyTblCnt;
                            int64 EntityOffst;
                            int64 someOtherOff;
                            int64 unk2;
                            int64 SubEntityOffst;
                            int64 someOtherOff2;
                            int64 unk3;
                            struct MapPosVertex
                            {
                                float Position[3];
                            } mpv[4];
                            //float Position2[3];
                            //float Position3[3];
                            //float Position4[3];
                            int32 dmy;
                            struct MapPosVertex2
                            {
                                float Position[3];
                            } mpv2[2];
                            struct ControlPoint
                            {
                                float Position[3];
                            } cpnt[2];
                            //float Position6[3];
                            int32 unk4;
                            int64 RefEntyPrmOffst;
                            int32 what[2];
                            int64 unknown;
                            //isTrigger IsTrigger;
                            //collisionLayer CollisionLayer;
                            //collisionQuality CollisionQuality;
                            //byte dbytes[5];
                        } c5;
                    }*/
                }
                if (ComponentCategory == CC_ComMapPath || ComponentCategory == CC_ComMapPath_V1)
                {
                    //TODO REWRITE THIS, MESSY AF
                    struct ComMapPath //?
                    {
                        if (!isNewEnty)
                        {
                            FSkip(4);
                            int64 eRefTblOffst;
                            int64 entityRefCnt;
                            char BlockChecker[4]<hidden = true>;
                            FSkip(-4);
                            if (BlockChecker == "ENTY" || BlockChecker == "_STR")
                            {
                                //terminateEntyDetection = 1;
                                //FSkip(-4);
                                //Printf("Entity ended early.");
                                break;
                                
                            }
                        }
                        else
                        {
                            int32 unk;
                            int64 LayoutNameOffst; //Offst?
                            int64 BinLytNameOffst;
                        }
                        if (unk != 0 || (!isNewEnty))
                        {
                            struct ERef
                            {
                                int64 entityOffst;
                                int64 prmOffstBeforeNextEnty;
                                int64 ePrmCnt;
                            } er[entityRefCnt];
                            if (!isNewEnty)
                            {
                                struct Vertices
                                {
                                    struct MapPathVertex
                                    {
                                        float Position[3];
                                    } mpvtx[2];
                                } vertexes;
                            }
                            else
                            {
                                struct Anchors
                                {
                                    struct MapPathAnchor
                                    {
                                        float Position[3];
                                    } mpa[2];
                                } anchors;
                            }
                            if (!isNewEnty)
                            {
                                struct ControlPoint
                                {
                                    float Position[3];
                                } ctrlp[2];
                            }
                            else
                            {
                                struct Tangent
                                {
                                    float Position[3];
                                } tngt[2];
                            }
                            int32 dmy;
                            if (!isNewEnty)
                            {
                                struct MapPathOtherVertexex
                                {
                                    float Position[3];
                                } mpvtxs[2];
                            }
                            else
                            {
                                struct MapPathAnchor2
                                {
                                    float Position[3];
                                } mpa2[2];
                            }
                            if (!isNewEnty)
                            {
                                struct ControlPoint2
                                {
                                    float Position[3];
                                } ctrlp2[2];
                            }
                            else
                            {
                                struct Tangent2
                                {
                                    float Pos[3];
                                } tngt2[2];
                            }
                            //int32 dmy2;
                            if (isNewEnty)
                            {
                                struct MapPathAnchor3
                                {
                                    float Position[3];
                                } mpa3[2];
                            }
                            //struct MapPathAnchor4
                            //{
                                //float Position[3];
                            //} mpa4[2];
                            if (isNewEnty)
                            {
                                struct Tangent3
                                {
                                    float Pos[3];
                                } tngt3[2];
                                int64 end;
                            }
                            boolChecker IsBezierConnect;
                            boolChecker unk[3];
                            int64 refEntyPrmOff;
                            int32 dmy2[2];
                            boolChecker unk2[4];
                            FSkip(4);
                        }
                        //} anchors;
                        //boolChecker IsTrigger;
                        //collisionLayer CollisionLayer;
                        //collisionQuality CollisionQuality;
                        //byte dbytes[5];
                    } cmp;
                }
                if (ComponentCategory == CC_ComGlobalLighting || ComponentCategory == CC_ComGlobalLighting_V1)
                {
                    struct ComGlobalLightingTbl
                    {
                        struct MainLight
                        {
                            int32 version;
                            int64 dmy;
                            float Position[3];
                            float Direction[3];
                            //int32 unk2[5];
                            float Intensity;
                            float Range;
                            float Color[3];
                            float OuterAngle;
                            float InnerAngle;
                        } mlght;
                        struct Fog
                        {
                            float Color0[3];
                            float Color1[3];
                            float Start0;
                            float End0;
                            float Density0;
                            float Start1;
                            float End1;
                            float Density1;
                        } fog;
                        FSkip(8);
                        struct ParticleFxColorScale
                        {
                            float ColorScale;
                            float ColorOffset[3];
                        } pfxcolorscale;
                        //FSkip(8)
                        struct Sky
                        {
                            float ColorScale;
                            float LightProbeIlluminanceScale;
                        } sky;
                        struct Ambient
                        {
                            float Color[3];
                            float ColorScale;
                        } ambient;
                        struct Hemisphere
                        {
                            float SkyDirection[3];
                            if (hdr.theHdr.major > 9)
                            {
                                float SkyColor[3];
                                float GroundColor[3];
                            }
                                float ColorScale;
                            //}
                        } hemisphere;
                        struct ShCoefficient
                        {
                            FSkip(4);
                            //if (hdr.theHdr.major == 11)
                            //{
                                //int64 RGBOff;
                            //}
                            if (hdr.theHdr.major == 12)
                            {
                                int64 RGBOff;
                            }
                            int64 SkyboxTextureOff;
                            int64 SpecularProbeTextureOff;
                            float Emissive; //yes this is here
                            FSkip(4);
                            float Red;
                            FSkip(32);
                            float Green;
                            FSkip(32);
                            float Blue;
                            if (hdr.theHdr.major > 3)
                            {
                                FSkip(36);  
                            }
                            else
                            {
                                FSkip(20);
                            }
                        } shc;
                    } cgl;
                }
                if (ComponentCategory == CC_ComMapLighting)
                {
                    struct ComMapLightingTbl
                    {
                        FSkip(4);
                        int64 MapOff;
                        int64 GlobalLightingOff;
                        boolChecker hasLightProbeBakePoints;
                        FSkip(1);
                        boolChecker hasReflectionProbes;
                        FSkip(1);
                        int16 nodeCntInLights; //should be 2
                        int16 nodeCntInLightProbeGrids;
                        int64 someOff[4];
                        int64 cpad[22];
                    } cml;
                }
                if (ComponentCategory == CC_ComCamera)
                {
                    struct ComCameraTbl
                    {
                        float ViewMatrix;
                        FSkip(44);
                        float ProjectionMatrix;
                        FSkip(60);
                        boolChecker IsToEnableAtStaged;
                        comCameraProjectionType ComCameraProjectionType;
                        byte cameraAnimationRefCnt;
                        FSkip(1);
                        float AspectRatio;
                        float FovyRadian;
                        float FrustumLeft;
                        float FrustumRight;
                        float FrustumTop;
                        float FrustumBottom;
                        float FrustumNearZ;
                        float FrustumFarZ;
                        float TextureOffset;
                        FSkip(4);
                        int64 CameraAnimationsOff;
                        int64 FilePath[cameraAnimationRefCnt];
                    } ccmratl;
                }
                if (ComponentCategory == CC_ComCloth)
                {
                    struct ComClothTbl
                    {
                        FSkip(4);
                        int64 FilePathOff;
                        float PerClothWindVelocity[3];
                        boolChecker IsAffectedByGlobalWind;
                        FSkip(3);
                    } ccltht;
                }
                if (ComponentCategory == CC_ComSprite)
                {
                    struct ComSpriteTbl
                    {
                        FSkip(4);
                        int64 TextureAssetPathOff;
                        float MultiplyColor[4];
                        float Size[2];
                        float SourceRectLeftTop[2];
                        float SourceRectSize[2];
                        float SourceRectPivot[2];
                        FSkip(4);
                        float AlphaTestThreshold;
                        float Order;
                        spriteBlendMode SpriteBlendMode;
                        byte  flag; //0 = no flags
                        FSkip(2);
                    } ccltht;
                }
                if (ComponentCategory == CC_ComFxTrigger)
                {
                    struct ComFxTriggerTbl
                    {
                        FSkip(4);
                        int64 FilePathOff;
                    } cfxtt;
                }
                if (ComponentCategory == CC_ComCharacter || ComponentCategory == CC_ComCharacter_V1)
                {
                    struct ComCharacterTbl
                    {
                        FSkip(4);
                        int64 ModelPathOff;
                        //int64 AudioNameOff;
                        boolChecker hasFrameAttrAssetNames;
                        FSkip(1);
                        boolChecker hasAnimations;
                        if (hasFrameAttrAssetNames == 0)
                        {
                            if (hasAnimations == 0)
                            {
                                FSkip(16);
                            }
                        }
                        FSkip(5);
                        if (hasFrameAttrAssetNames)
                        {
                            int64 FrameAttrFilePathValueOff;
                        }
                        if (hasAnimations)
                        {
                            int64 AnimFilePathValueOff;
                        }
                        //int64 unk[2];
                        int64 ParticleFxAssetPathOff;
                        int64 AudioAssetPathOffOff;
                        int64 FxTriggerAssetPathOff;
                        if (hasFrameAttrAssetNames)
                        {
                            int64 FrameAttrFilePathOff;
                        }
                        if (hasAnimations && isNewEnty)
                        {
                            int64 AnimFilePathOff;
                        }
                        //int64 
                    } cchart;
                }
            } prt;
        }
        if (scriptCnt != 0)
        {
            char BlockChecker[4]<hidden = true>;
            FSkip(-4);
            if (BlockChecker == "ENTY" || BlockChecker == "_STR")
            {
                //terminateEntyDetection = 1;
                //FSkip(-4);
                //Printf("Entity ended early.");
                break;
                
            }
            //if (srt.ScriptParamTblSize != 0)
            //{
                
                for (i = 0; i < scriptCnt; i++)
                {
                    struct ScriptParamTbl
                    {
                        
                        //int64 prmTblOffst[2];
                        //int64 unk;
                        //for (i = 0; i < 2; i++)
                        //{
                            struct ScriptParam
                            {
                                int64 ScriptPrmTblOffst[srt.ScriptParamCnt];
                                scriptParamType ScriptParamType;
                                
                                if (ScriptParamType == ScriptParamType_Int)
                                {
                                    struct EntityIntParam
                                    {
                                        int64 ParamKeyOffst[2];
                                    } eip;
                                }
                                
                                if (ScriptParamType == ScriptParamType_Entity)
                                {
                                    struct EntityScriptParam
                                    {
                                        int64 ParamKeyOffst;
                                        byte  scriptGUID[16];
                                    } esp;
                                }
                                if (ScriptParamType == ScriptParamType_Float)
                                {
                                    struct EntityFloatParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        float Value;
                                        int32 dmy;
                                    } efp;
                                }
                                if (ScriptParamType == ScriptParamType_String)
                                {
                                    struct EntityStringParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        int64 Value;
                                        //int32 dmy;
                                    } estrp;
                                }
                                if (ScriptParamType == ScriptParamType_ScriptRef)
                                {
                                    struct EntityScriptRefParam
                                    {
                                        //int64 unk;
                                        int64 ParamKeyOffst;
                                        int64 Value;
                                        //int32 dmy;
                                    } estrp;
                                }
                                //int64 ScriptFilePathOffst;
                                //byte  scriptGUID[16];
                            } scriptPrm;
                        //}
                    } sptbl;
                //}
            }
        }
        //WIP
        /*char BlockChecker2[4]<hidden = true>;
        FSkip(-4);
        if (BlockChecker2 == "ENTY" || BlockChecker2 == "_STR")
        {
            //terminateEntyDetection = 1;
            //FSkip(-4);
            //Printf("Entity ended early.");
            break;        
        }
        else
        {
            FSkip(72); //idk
        }*/
    }   
} enty<comment="Entity Chunk">;

typedef struct CommonNinNXHdr
{
    char hdr[8];
    byte micro;
    byte minor;
    int16 major;
    Printf("Entity Info:\n");
    Printf("Version: TODO!\n");
    if (major > 5)
    {
        isNewEnty = 1;
        Printf("Ver 5+\n");
    }
    int16 endian;
    byte alignment;
    byte addressSize;
    int32 fNameOffst;
    int16 flags;
    int16 firstBlockOffst;
    int32 relocBlockOffst;
    int32 fsize;
} ninNXHdr<bgcolor = cBlue>;

struct Entity
{
    struct Header
    {
        ninNXHdr theHdr;
    } hdr<comment="Common NX Hdr">;
    struct Content
    {
        int64 entityChunkOffst<bgcolor = cYellow>;
        int64 unk<bgcolor = cYellow>;
        int64 entityBlockOffst<bgcolor = cYellow>;
        enty theMainEntity<bgcolor = cGreen>;
        for (i = 0; i < 99; i++)
        {
            struct TheNextBlock
            {
                char nextBlockType[4]<hidden=true>;
                if (nextBlockType == "ENTY")
                {
                    FSkip(-4);
                    struct NextEnty
                    {
                        enty theNextEntity<bgcolor = cBlue>;
                    } nEnty;
                }
                //FSkip(4);
                if (nextBlockType == "_STR")
                {
                    FSkip(-4);
                    strTbl theStringTable<bgcolor = cPurple>;
                    terminateStrTblDetection = 1;
                }
                if (terminateStrTblDetection == 1)
                {
                    reloc theRelocTbl<bgcolor=cRed>;
                }
            } nb;
            if (terminateStrTblDetection == 1)
            {
                break;
            }
        } //tnb;
    } content<comment="Bezel Entity Bin Content">;
} entity<comment="Binary NintendoWare Bezel Engine Entity">;