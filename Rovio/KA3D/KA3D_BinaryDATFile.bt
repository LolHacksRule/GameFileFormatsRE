//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: KA3DBinaryDATFile.bt
//   Authors: LolHacksRule
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../LHR/Common.bt"

//Viewing of data files from Rovio's proprietary version of the KA3D Engine (Later named Fusion).

local string theLabelID <hidden=true> = "";
local uint DEBUG_PRINT <hidden = true> = 0;

//MANUAL FIXES FOR HEADERLESS BINARIES, ONLY SET 1, ONLY TESTED ON DARKEST FEAR iOS AND ANGRY BIRDS 1.2.2!
local uint forceHeaderlessText <hidden = true> = 0;
local uint forceHeaderlessFont <hidden = true> = 0;
local uint forceHeaderlessSprite <hidden = true> = 0;

typedef enum <DWORD>
{
    KA3D_BlockType_KA3D = 1262564164, //ABC v1.4.2
    KA3D_BlockType_KA3D_RVIO = 1381386575,
    KA3D_BlockType_CompoSprite = 1129270608,
    KA3D_BlockType_Text = 1413830740,
    KA3D_BlockType_LanguageData = 1279541588,
    KA3D_BlockType_LabelIDs = 1279870035,
    KA3D_BlockType_TextGroup = 1415071568,
    KA3D_BlockType_Sprite = 1397772884,
    KA3D_BlockType_Font = 1179602516,
    KA3D_BlockType_Anim = 1095649613, //ABC v2.1.0 (Unused?) / ABR INGAME_ANIMATIONS
} KA3D_BlockType;

typedef struct
{
    KA3D_BlockType contentBlockType;
    DWORD blockSize; //-4
    //SHORT ver; //We exclude this here as chunks have it and it counts towards blockSize
} KA3DBlockHeader;

/*typedef struct
{
    local string theLabelIDString = LabelIDs.LabelIDsStruct.LabelIDStrings.theLabelIDStr[i].theString;
    short textStringSize<hidden=true>;
    if (textStringSize >= 1)
    {
        char theTextString[textStringSize];
    }
    else
    {
        Printf("TextString %i is empty!\n", i);
    }
} textString;*/

typedef struct
{
    KA3DBlockHeader BaseCompositeBlockHdr;
    struct
    {
        SHORT ver; //Always 1, even on RVIO, that's why we use it to tell the version.
        SHORT texCnt;
        if (DEBUG_PRINT)
        {
            Printf("Textures: %i\n", texCnt);
        }
        struct 
        {
            I16_StringEntry compoName;
            short sprites;
            if (DEBUG_PRINT) Printf("--------COMPOSITE \"%s\" (%i) START--------\n", compoName.theString, i);
            if (DEBUG_PRINT) Printf("\tSprites: %i\n", sprites);
            struct
            {
                I16_StringEntry name;
                if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                {
                    FPos = FTell();
                    I16_StringEntry sheetName;
                }
                Vector2_I16 pos;
                if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                {
                    Vector2_F32 scale;
                    float angle;
                    Byte_Bool flip[2];
                }
                if (DEBUG_PRINT)
                {
                    Printf("\t\t--------SPRITE \"%s\" (%i) START --------\n", name.theString, i2);
                    Printf("\t\tX Offset: %d\n", pos.X);
                    Printf("\t\tY Offset: %d\n", pos.Y);
                    if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                    {
                        Printf("\t\tSheet Name: \"%s\"\n", ReadShort(FPos) > 0 ? sheetName.theString : "");
                        Printf("\t\tScale: (%f,%f)\n", scale.X, scale.Y);
                        Printf("\t\tAngle: %f\n", angle);
                        Printf("\t\tFlip: (%s,%s)\n", EnumToString(flip[0]), EnumToString(flip[1]));
                    }
                    Printf("\t\t--------SPRITE \"%s\" (%i) END--------\n", name.theString, i2);
                    i2++;
                }
            } Sprite[sprites]<optimize=false>;
            i2 = 0;
            if (DEBUG_PRINT) Printf("--------COMPOSITE \"%s\" (%i) END--------\n", compoName.theString, i);
            if (BaseHeader.contentBlockType != KA3D_BlockType_KA3D_RVIO && ver != 1) //Ver 1 doesn't use padding so here's a fix for legacy DAT
            {
                FSkip(2);
            }
            i++;
        } TextureData[texCnt]<optimize=false>;
        i = 0;
        //FSkip(2);
    } CompoSpriteBlockBinary;
} COMPBlock;

typedef struct
{
    if (forceHeaderlessText != 1)
    {
        KA3DBlockHeader BaseTextDataBlockHeader;
    }
    struct
    {
        if (forceHeaderlessText != 1)
        {
            SHORT ver;
        }
        else
        {
            byte dmy;
        }
        struct
        {
            if (forceHeaderlessText != 1)
            {
                KA3DBlockHeader languageDataBlockHeader;
            }
            else
            {
                DWORD blockDataSize;
            }
            struct
            {
                if (forceHeaderlessText != 1)
                {
                    SHORT languageCount;
                }
                else
                {
                    byte languageCount;
                    //byte dmy;
                }
                I16_StringEntry Language[languageCount]<optimize=false>;
            } LanguageDataStruct;
        } LanguageData;
        struct
        {
            if (forceHeaderlessText != 1)
            {
                KA3DBlockHeader labelIDDataBlockHeader;
            }
            struct
            {
                SHORT labels;
                I16_StringEntry LabelID[labels]<optimize=false>;
            } LabelIDsStruct;
        } LabelIDs;
        if (forceHeaderlessText == 1)
        {
            int32 offset_legacy[LanguageData.LanguageDataStruct.languageCount]; //from the current pos, this is the offset
        }
        struct
        {
            for (i2 = 0; i2 < LanguageData.LanguageDataStruct.languageCount; i2++)
            {
                struct
                {
                    local string theLanguage = LanguageData.LanguageDataStruct.Language[i2].theString;
                    if (forceHeaderlessText != 1)
                    {
                        KA3DBlockHeader textGroupBlockHdr;
                    }
                    struct
                    {
                        if (DEBUG_PRINT)
                        {
                            Printf("-----%s LANGUAGE START-----\n", LanguageData.LanguageDataStruct.Language[i2].theString); //Remove to print string IDs
                        }
                        for (i = 0; i < LabelIDs.LabelIDsStruct.labels; i++)
                        {
                            //struct TextGroupString
                            //{
                                //local string theLabelID = LabelIDs.LabelIDsStruct.LabelIDStrings.lid_str[i].theStr.theString;
                                theLabelID = LabelIDs.LabelIDsStruct.LabelID[i].theString;
                                I16_StringEntry TextGroupString;
                                if (DEBUG_PRINT)
                                {
                                    Printf("%s", LabelIDs.LabelIDsStruct.LabelID[i].theString);
                                    if (sizeof TextGroupString[i] > 2)
                                    {
                                        Printf("\t%s", TextGroupString[i].theString);
                                    }
                                    Printf("\n");
                                }
                            //} txgp_str;
                        }
                        if (DEBUG_PRINT)
                        {
                            Printf("-----%s LANGUAGE END-----\n", LanguageData.LanguageDataStruct.Language[i2].theString);
                        }
                    } TextGroupData;
                } TextGroup;
            }
        } TextGroupSet;
    } TextBlockBinary;
} TEXTBlock<bgcolor=cGreen>;

typedef struct
{
    if (forceHeaderlessSprite != 1)
    {
        KA3DBlockHeader BaseSpriteBlockHdr;
    }
    struct
    {
        if (forceHeaderlessSprite != 1)
        {
            SHORT ver;
        }
        I16_StringEntry textureFileName;
        SHORT maxTextures;
        if (DEBUG_PRINT)
        {
            Printf("Texture (%s) Param:\n", textureFileName.theString);
        }  
        struct
        {
            I16_StringEntry name;
            Vector2_I16 pos;
            SHORT width;
            SHORT height;
            Vector2_I16 pivot;
            if (DEBUG_PRINT)
            {
                Printf("\t--------TEXTURE %s START--------\n", name.theString);
                Printf("\tPosition: (%d,%d)\n", pos.X, pos.Y);
                Printf("\tResolution: %dx%d\n", width, height);
                Printf("\tPivot: (%d,%d)\n", pivot.X, pivot.Y);
                Printf("\t--------TEXTURE %s END--------\n", name.theString);
            }
        } Texture[maxTextures]<optimize=false>;
    } SpriteBlockBinary;
} SPRTBlock;

typedef struct
{
    if (forceHeaderlessFont != 1)
    {
        KA3DBlockHeader BaseFontBlockHdr;
    }
    struct
    {
        if (forceHeaderlessFont != 1)
        {
            SHORT ver;
        }
        I16_StringEntry textureFileName;
        if (DEBUG_PRINT)
        {
            Printf("Font (%s) Param:\n", textureFileName.theString);
        } 
        SHORT leading; //or spacing
        SHORT tracking; //or leading
        SHORT fontChars;
        struct
        {
            //As of a new format, this changed I think
            /*
            SHORT xOff;
            SHORT yOff;
            SHORT width;
            SHORT height;
            SHORT unk2[2];
            */
            
            wchar_t charCode; //I32 in v1 //or code
            Vector2_I16 pos;
            SHORT width;
            SHORT height;
            SHORT vpivot; //or baseline
            if (DEBUG_PRINT)
            {
                Printf("\t--------CHARACTER %s START--------\n", WStringToString(charCode, CHARSET_UTF8));
                Printf("\tPosition: (%d,%d)\n", pos.X, pos.Y);
                Printf("\tResolution: %dx%d\n", width, height);
                Printf("\tBaseline: %d\n", vpivot);
                Printf("\t--------CHARACTER %s END--------\n", WStringToString(charCode, CHARSET_UTF8));
            }
        } FontCharacter[fontChars]<optimize=false>;
    } FontBlockBinary;
} FONTBlock;

typedef struct
{
    KA3DBlockHeader BaseAnimBlockHdr;
    struct
    {
        SHORT ver;
        SHORT anims;
        struct
        {
            I16_StringEntry animName;
            SHORT frames;
            struct //?
            {
                I16_StringEntry name; //ANIM is the default name it seems
                DWORD count; //?
                struct //?
                {
                    I16_StringEntry name; //?
                    byte unk[12]; //? Ok this is stupid bcz this is 10 on legacy while it's 12 on the latest revision
                } Anim[count]<optimize=false>;
            } Frame[frames]<optimize=false>;
        } Anim[anims]<optimize=false>;
    } AnimBlockBinary;
} ANIMBlock;

struct KA3DBinary
{
    BigEndian();
    //Check for headerless file
    if (ReadUByte() == 0) //if you find 0, it's the old headerless format
    {
        if (forceHeaderlessText == 1)
        {
            Printf("Forcing headerless Text block detection!\n");
            TEXTBlock HeaderlessTextBlock;
            break;
        }
        else if (forceHeaderlessSprite == 1)
        {
            Printf("Forcing headerless Sprite block detection!\n");
            SPRTBlock HeaderlessSpriteBlock;
            break;
        }
        else if (forceHeaderlessFont == 1)
        {
            Printf("Forcing headerless Font block detection!\n");
            FONTBlock HeaderlessFontBlock;
            break;
        }
        else
        {
            Printf("Headerless file detected! Please modify the manual flags to detect its data.\n");
            break;
        }
    }
    else
    //Detect newer KA3D format
    forceHeaderlessText = 0; //A bit redundant but
    forceHeaderlessFont = 0;
    forceHeaderlessSprite = 0;
    {
        KA3DBlockHeader BaseHeader;
        switch (ReadString(FTell(),4))
        {
            case "COMP": COMPBlock CompoSpriteBlock<bgcolor=cRed>; break;
            case "TEXT": TEXTBlock TextBlock<bgcolor=cGreen>; break;
            case "SPRT": SPRTBlock SpriteBlock<bgcolor=cBlue>; break;
            case "FONT": FONTBlock FontBlock<bgcolor=cPurple>; break;
            //case "ANIM": ANIMBlock AnimBlock<bgcolor=cYellow>; break; //WIP
        }
    }
} KA3D_DAT<bgcolor=cYellow>;