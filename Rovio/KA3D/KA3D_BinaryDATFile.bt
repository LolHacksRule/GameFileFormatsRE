//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: KA3DBinaryDATFile.bt
//   Authors: LolHacksRule
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "../../LHR/Common.bt"

//Viewing of data files from Rovio's proprietary version of the KA3D Engine (Later named Fusion).

local string theLabelID <hidden=true> = "";
local uint DEBUG_PRINT <hidden = true> = 0;

//MANUAL FIXES FOR HEADERLESS BINARIES, ONLY SET 1, ONLY TESTED ON DARKEST FEAR iOS AND ANGRY BIRDS 1.2.2!
local uint forceHeaderlessText <hidden = true> = 0;
local uint forceHeaderlessFont <hidden = true> = 0;
local uint forceHeaderlessSprite <hidden = true> = 0;

typedef enum <DWORD>
{
    KA3D_BlockType_KA3D = 1262564164, //ABC v1.4.2
    KA3D_BlockType_KA3D_RVIO = 1381386575,
    KA3D_BlockType_CompoSprite = 1129270608,
    KA3D_BlockType_Text = 1413830740,
    KA3D_BlockType_LanguageData = 1279541588,
    KA3D_BlockType_LabelIDs = 1279870035,
    KA3D_BlockType_TextGroup = 1415071568,
    KA3D_BlockType_Sprite = 1397772884,
    KA3D_BlockType_Font = 1179602516,
    KA3D_BlockType_Anim = 1095649613, //ABC v2.1.0 (Unused?) / ABR INGAME_ANIMATIONS
} KA3D_BlockType;

typedef struct
{
    /*if (!(forceHeaderlessText && forceHeaderlessFont && forceHeaderlessSprite)*/ KA3D_BlockType contentBlockType;
    DWORD blockSize; //-4, if left or right mismatches engine dies
    //SHORT ver; //We exclude this here as chunks have it and it counts towards blockSize
} KA3DBlockHeader;

/*typedef struct
{
    local string theLabelIDString = LabelIDs.LabelIDsStruct.LabelIDStrings.theLabelIDStr[i].theString;
    short textStringSize<hidden=true>;
    if (textStringSize >= 1)
    {
        char theTextString[textStringSize];
    }
    else
    {
        Printf("TextString %i is empty!\n", i);
    }
} textString;*/

typedef struct
{
    KA3DBlockHeader BaseCompositeBlockHdr;
    struct
    {
        SHORT ver; //1 and 2 which is seen in Rio but RVIO is always 1 so we use it to tell the version
        SHORT texCnt;
        if (DEBUG_PRINT)
        {
            Printf("Textures: %i\n", texCnt);
        }
        struct 
        {
            I16_StringEntry compoName;
            short sprites;
            if (DEBUG_PRINT) Printf("--------COMPOSITE \"%s\" (%i) START--------\n", compoName.theString, i);
            if (DEBUG_PRINT) Printf("\tSprites: %i\n", sprites);
            struct
            {
                I16_StringEntry name;
                if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                {
                    FPos = FTell();
                    I16_StringEntry sheetName;
                }
                Vector2_I16 pos;
                if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                {
                    Vector2_F32 scale;
                    float angle;
                    Byte_Bool flip[2];
                }
                if (DEBUG_PRINT)
                {
                    Printf("\t\t\"%s\" (%i): X Offset: %d, Y Offset: %d", name.theString, i2, pos.X, pos.Y);
                    if (BaseHeader.contentBlockType == KA3D_BlockType_KA3D_RVIO)
                    {
                        Printf("\t\tSheet Name: \"%s\", Scale: (%f,%f), Angle: %f, Flip: (%f,%f)", ReadShort(FPos) > 0 ? sheetName.theString : "", scale.X, scale.Y, angle, flip[0] ? -1.0 : 1.0, flip[1] ? -1.0 : 1.0);
                    }
                    Printf("\n");
                    i2++;
                }
            } Sprite[sprites]<optimize=false>;
            if (ver == 2)
            {
                SHORT refPoints; //Always 0? Unused?
                if (!refPoints) break;
                struct
                {
                    I16_StringEntry unk;
                    SHORT unk2;
                    SHORT unk3;
                } ReferencePoint[refPoints]<optimize=false>;
                if (refPoints > 0) Printf("%i\n", refPoints);
            }
            i2 = 0;
            if (DEBUG_PRINT) Printf("--------COMPOSITE \"%s\" (%i) END--------\n", compoName.theString, i);
            i++;
        } TextureData[texCnt]<optimize=false>;
        i = 0;
    } CompoSpriteBlockBinary;
} COMPBlock;

typedef struct
{
    if (forceHeaderlessText != 1)
    {
        KA3DBlockHeader BaseTextDataBlockHeader;
    }
    struct
    {
        if (forceHeaderlessText != 1)
        {
            SHORT ver;
        }
        else
        {
            byte dmy;
        }
        struct
        {
            if (forceHeaderlessText != 1)
            {
                KA3DBlockHeader languageDataBlockHeader;
            }
            else
            {
                DWORD blockDataSize;
            }
            struct
            {
                if (forceHeaderlessText != 1)
                {
                    SHORT languageCount;
                }
                else
                {
                    byte languageCount;
                    //byte dmy;
                }
                I16_StringEntry Language[languageCount]<optimize=false>;
            } LanguageDataStruct;
        } LanguageData;
        struct
        {
            if (forceHeaderlessText != 1)
            {
                KA3DBlockHeader labelIDDataBlockHeader;
            }
            SHORT labels;
            I16_StringEntry LabelID[labels]<optimize=false>;
        } LabelIDs;
        if (forceHeaderlessText == 1)
        {
            int32 offset_legacy[LanguageData.LanguageDataStruct.languageCount]; //from the current pos, this is the offset
        }
        struct
        {
            local string theLanguage = LanguageData.LanguageDataStruct.Language[i].theString;
            if (forceHeaderlessText != 1)
            {
                KA3DBlockHeader textGroupBlockHdr;
            }
            if (DEBUG_PRINT)
            {
                Printf("-----%s LANGUAGE START-----\n", LanguageData.LanguageDataStruct.Language[i].theString); //Remove to print string IDs
            }
            //theLabelID = LabelIDs.LabelID[i2].theString; //Temporarily hide
            I16_StringEntry TextGroupString[LabelIDs.labels]<optimize=false>;
            if (DEBUG_PRINT) //TODO dump this as a CSV
            {
                for (i2 = 0; i2 < LabelIDs.labels; i2++)
                {
                    Printf("%s", LabelIDs.LabelID[i2].theString);
                    if (TextGroupString[i2].byteSize)
                    {
                        Printf("\t%s", TextGroupString[i2].theString);
                    }
                    Printf("\n");
                }
                Printf("-----%s LANGUAGE END-----\n", LanguageData.LanguageDataStruct.Language[i].theString);
            }
            i++;
        } TextGroupSet[LanguageData.LanguageDataStruct.languageCount]<optimize=false>;
        i = 0;
    } TextBlockBinary;
} TEXTBlock<bgcolor=cGreen>;

typedef struct
{
    if (forceHeaderlessSprite != 1)
    {
        KA3DBlockHeader BaseSpriteBlockHdr;
    }
    struct
    {
        if (forceHeaderlessSprite != 1)
        {
            SHORT ver;
        }
        I16_StringEntry textureFileName;
        SHORT maxTextures;
        if (DEBUG_PRINT)
        {
            Printf("-----TEXTURE FILE (%s) PARAM START-----\n", textureFileName.theString);
        }  
        struct
        {
            I16_StringEntry name;
            Vector2_I16 pos;
            SHORT width;
            SHORT height;
            Vector2_I16 pivot;
            if (DEBUG_PRINT)
            {
                Printf("\t%s (%i): Position: (%d,%d), Resolution: (%dx%d), Pivot: (%d,%d)\n", name.theString, i, pos.X, pos.Y, width, height, pivot.X, pivot.Y);
                i++;
            }
        } Texture[maxTextures]<optimize=false>;
        if (DEBUG_PRINT)
        {
            Printf("----TEXTURE FILE (%s) PARAM END----\n", textureFileName.theString);
        }
        i = 0;
    } SpriteBlockBinary;
} SPRTBlock;

typedef struct
{
    if (forceHeaderlessFont != 1)
    {
        KA3DBlockHeader BaseFontBlockHdr;
    }
    struct
    {
        if (forceHeaderlessFont != 1)
        {
            SHORT ver;
        }
        I16_StringEntry textureFileName;
        if (DEBUG_PRINT)
        {
            Printf("FONT FILE (%s) CHARACTER PARAM START:\n", textureFileName.theString);
        } 
        SHORT leading; //or spacing
        SHORT tracking; //or leading
        SHORT fontChars;
        struct
        {
            //As of a new format, this changed I think
            /*
            SHORT xOff;
            SHORT yOff;
            SHORT width;
            SHORT height;
            SHORT unk2[2];
            */
            
            wchar_t charCode; //I32 in v1 //or code
            Vector2_I16 pos;
            SHORT width;
            SHORT height;
            SHORT vpivot; //or baseline
            if (DEBUG_PRINT)
            {
                Printf("\t%s (%i): Position: (%d,%d), Resolution: (%dx%d), Baseline: %d\n", WStringToString(charCode, CHARSET_UTF8), i, pos.X, pos.Y, width, height, vpivot);
                i++;
            }
        } FontCharacter[fontChars]<optimize=false>;
        if (DEBUG_PRINT)
        {
            Printf("FONT FILE (%s) CHARACTER PARAM END\n", textureFileName.theString);
        }
    } FontBlockBinary;
} FONTBlock;

typedef struct
{
    KA3DBlockHeader BaseAnimBlockHdr;
    struct
    {
        SHORT ver;
        SHORT anims;
        struct
        {
            I16_StringEntry animName;
            SHORT frames;
            struct //?
            {
                I16_StringEntry name; //ANIM is the default name it seems
                DWORD count; //?
                struct //?
                {
                    I16_StringEntry name; //?
                    byte unk[12]; //? Ok this is stupid bcz this is 10 on legacy while it's 12 on the latest revision
                } Anim[count]<optimize=false>;
            } Frame[frames]<optimize=false>;
        } Anim[anims]<optimize=false>;
    } AnimBlockBinary;
} ANIMBlock;

struct KA3DBinary
{
    BigEndian();
    //Check for headerless file
    if (ReadUByte() == 0) //if you find 0, it's the old headerless format
    {
        if (forceHeaderlessText == 1)
        {
            Printf("Forcing headerless Text block detection!\n");
            TEXTBlock HeaderlessTextBlock;
        }
        else if (forceHeaderlessSprite == 1)
        {
            Printf("Forcing headerless Sprite block detection!\n");
            SPRTBlock HeaderlessSpriteBlock;
        }
        else if (forceHeaderlessFont == 1)
        {
            Printf("Forcing headerless Font block detection!\n");
            FONTBlock HeaderlessFontBlock;
        }
        else
        {
            Printf("Headerless file detected! Please modify the manual flags to detect its data.\n");
            break;
        }
    }
    else
    {
        //Detect newer KA3D format
        forceHeaderlessText = 0; //A bit redundant but
        forceHeaderlessFont = 0;
        forceHeaderlessSprite = 0;
        {
            KA3DBlockHeader BaseHeader;
            while (FTell() != EOF) //Unused behavior, files normally consist of one of these chunks.
            {
                switch (ReadString(FTell(),4))
                {
                    case "COMP": COMPBlock CompoSpriteBlock<bgcolor=cRed>; break;
                    case "TEXT": TEXTBlock TextBlock<bgcolor=cGreen>; break;
                    case "SPRT": SPRTBlock SpriteBlock<bgcolor=cBlue>; break;
                    case "FONT": FONTBlock FontBlock<bgcolor=cPurple>; break;
                    //case "ANIM": ANIMBlock AnimBlock<bgcolor=cYellow>; break; //WIP
                }
            }        
        }
    }
} KA3D_DAT<bgcolor=cYellow>;