//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//		File: PXPackage.bt
//	 Authors: LolHacksRule
//	 Version: 
//	 Purpose: 
//	Category: 
// File Mask: 
//	ID Bytes: 
//	 History: 
//------------------------------------------------

#include "PXCommon.bt"

typedef enum <uint32>
{
    PX_PackageFlag_U32_Raw = 0,
    PX_PackageFlag_U32_UseCompression = 2,
    PX_PackageFlag_U32_UseCompression_Legacy,
} PX_PackageFlag_U32;

typedef enum <ubyte>
{
	PX_PackageFlag_UByte_Raw = 0,
    PX_PackageFlag_UByte_UseCompression = 2,
    PX_PackageFlag_UByte_UseCompression_Legacy,
    PX_PackageFlag_UByte_UseCompression_2014,
    PX_PackageFlag_UByte_UseCompression_ZP1_PS3 = 131, //Idk
} PX_PackageFlag_UByte;

typedef enum <uint32>
{
    PX_PackageVariantType_Simple_Legacy, //PFX1 X360
	PX_PackageVariantType_Simple,
    PX_PackageVariantType_Hashed,
    PX_PackageVariantType_XOR, //PFX3 (PC) / Zen Pinball mobile newer
} PX_PackageVariantType;

struct PXPackage
{
	LittleEndian();
    uint32 checkForJenkinsHashHdr<hidden=true>;
    FSkip(-4);
    if (checkForJenkinsHashHdr == 2937534864)
    {
        struct JenkinsHash
        {
            uint32 jenkinsHasherMagic;
            uint32 strSz;
            char hashedStr[strSz];
        } jh;
    }
	PX_BinaryHeader PXBinaryHeader;
	PX_PackageVariantType PXPDataType; //Since this is inconsistent in PFX2 and usable in multiple titles, it's prob wise to refer to this as type instead of ver
	if (PXPDataType <= 2)
	{
		uint32 files;
		uint32 metaTableSz;
		if (PXPDataType == 0)
		{
			FSkip(-4);
		}
		uint32 isXOR<hidden=true>;
		FSkip(-4);
	}
	else
	{
		Printf("PXP XOR variant is WIP!");
		uint64 PXPSz;
        byte dmy[32]; //MD5?
		uint32 XORMetaSz;
        struct TableOfContentsXOR
        {
            uint32 sz;
            uint32 xSz[2];
            uint32 XORMetaTableCryptKey;
            uint32 XORMetaTableCRC32;
            //byte dmy2[36];
            //uint32 files;
        } TOC_XOR;
        byte XORMeta[XORMetaSz];
		FSeek(0);
		byte PXP[PXPSz];
		break;
	}
	if (PXPDataType == 2) //ZP1 PS3, ZP2 patch wiiu/ps4 and PFX3 Win10 because Zen, haven't tested others
	{
        //why, if these mismatch game dies
		uint16 unk[2]; //the other is 3d90, on small files 0x02 is 0xEA
		uint16 unk2[2]; //the other is ccf8, on small files 0x02 is 0x48
		uint16 unk3[2]; //the other is 3990, on small files 0x02 is 0x17
		uint32 unk4; //Some other CRC?
        uint32 metaTableCRC32;
	}
	struct FileMetaData
	{
		for (i = 0; i < files; i++)
		{
			struct MetaEntry
			{
				uint32 dataOff;
				uint32 uncDSz;
				if (PXPDataType == 0)
				{
					uint32 cSz;
					PX_PackageFlag_U32 flags;
					Byte_StringEntry fileName;
				}
				else
				{
					PX_PackageFlag_UByte flags;
					Byte_StringEntry fileName;
					//Printf("%s\n", fileName.theString);
					//Printf("%s\n", fileName.theString);
					for(i2 = 0; i2 < 4; i2++ )
					{
						struct PaddingChecker
						{
							byte dmy;
							if (dmy == 0x00)
							{
								//FSkip(1);
								//break;
							}
							else
							{
								break;
							}
						} padChk<hidden = true>;
						if (padChk.dmy != 0x00)
						{
							FSkip(-1);
							break;
						}
					}
					//idk
					uint32 checkForUnusuallyLargeNum<hidden=true>;
					FSkip(-4);
					if (checkForUnusuallyLargeNum >= 10000000 && checkForUnusuallyLargeNum != 1179011410)
					{
						FSkip(-1);
					}
                    //If reading 2008 PXP, comment out this and the below value
                    if (flags == 3)
                    {
                        uint32 legacyCsz;
                    }
					uint32 cSz;
				}
				/*byte type;
				FSkip(3);
				uint32 unk;*/
			} MetaEntryStruct;
		}
	} FileMetaDataStruct;
    /*
	struct FileEntries
	{
		for (i = 0; i < files; i++)
		{
            FSeek(fmd.mentry[i].dataOff);
			struct FileEntry
			{   
				//byte data[fmd.mentry[i].cSz];
				if (fmd.mentry[i].flags == 0)
				{
					byte data[fmd.mentry[i].uncDSz];
				}
				else if (PXPDataType == 0)
				{
					byte data[fmd.mentry[i].cSz];
				}
				else
				{
					byte chunkType;
					if (PXPDataType == 0)
					{
						uint16 chunkSz;
					}
					else
					{
						uint32 chunkSz : 24;
                        FSkip(-1);
					}
					if (chunkType < 2 && chunkType != 0)
					{
						uint16 chunkCSz;
					}
					else if (chunkType == 4 || chunkType == 14)
					{
						uint32 chunkCSz : 24;
                        FSkip(-1);
					}
					else
					{
						Printf("Error!");	 
					}
				}
                FSkip(-7);
                //if (PXPDataType == 2)
                {
                    if (fmd.mentry[i].flags > 0)
                    {
                        byte file[fmd.mentry[i].cSz]<optimize=false>;
                    }
                    else
                    {
                        byte file[fmd.mentry[i].uncDSz]<optimize=false>;
                    }
                }
			} fen;
		}
	} fens;
    */
} PXP;