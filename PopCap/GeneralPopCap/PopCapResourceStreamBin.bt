//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: PopCapResourceStreamBin.bt
//      Authors: LolHacksRule
//      Version: 1
//      Purpose: Gets data out of the binary.
//      Category: Meta
//      File Mask: rsb1
//      ID Bytes:
//      History: 
//------------------------------------------------

/*
General Format Info:
https://github.com/TwinKleS-C/PvZTool/blob/53be6e2364381515b8d4b37c4f51fe562a20034d/src/pvztool.c https://github.com/Nineteendo/PVZ2tools/blob/183078174f3bda15bd06f7fefd0cbf4ebb8bf4e8/OBBEdit/README.md
http://www.watto.org/specs.html?specs=Archive_RSB_1BSR
https://github.com/YingFengTingYu/PopStudio
*/

//Tested on various.

local int ver4Rsb <hidden=true> = 0;
local int i <hidden=true> = 0;
local int isCompressedPTXFile <hidden=true> = 0;

typedef enum <int32> {
	ARGB8888,
    RGB565,
    DXT3 = 5, //PS4/Xbox 360
    ETC1_RGB_A8 = 147,
    RGBA4444_BLOCK = 21 //?
} ImageFormat;

typedef enum <int32>
{
    AlphaFmt_ETC1_RGB_A = 100
} AlphaFormat;

typedef enum <int32> {
    Resident,
	GPU_Transfer,
    Transient
} ResType;

typedef struct SubGroupInfo
{
    byte subGroupInfoData[rsb1Hdr.resGroupInfoTableItemSize];
    /*string thePoolName;
    FSkip(128 - sizeof thePoolName); 
    FSkip(4);*/
} subGroupInfo;

typedef struct ResGroupInfo
{
    byte subGroupInfoData[rsb1Hdr.resGroupFileNameTableItemSize];
} resGroupInfo;

typedef struct AutoPool
{
    //byte autoPoolData[rsb1Hdr.AutoPoolTableItemSize];
    string thePoolName;
    FSkip(128 - sizeof thePoolName); 
    int32 resGroupFileOffset;
    int32 resGroupFileSize;
    int32 autoPoolNum;
    int32 commonSize; //3?
    int32 cFileLocation;
    int32 cFileMemSize;
    //int32 dFileLocation;
    //int32 dFileFileSize;
    //int32 dFileMemSize;
} autoPool;

typedef struct PTXInfo
{
    int32 width;
    int32 height;
    int32 pitch;
    ImageFormat textureFormat;
    if (rsb1Hdr.ptxInfoTableItemSize == 20) //Helps with DEV1/2 RSBs from PVZ2C
    {
        int32 alphaSize; //Is it alphaSize?
    }
    if (rsb1Hdr.ptxInfoTableItemSize == 24)
    {
        int32 alphaSize;
        AlphaFormat alphaFormat;
    }
} ptxInfo;

typedef struct ResListXMLPtxInfo
{
    struct Part1
    {
        int32 unkxml[4];
    } rl_xptxhdrpart1;
    struct Part2
    {
        uint16 xmlPTXtype;
        uint16 xmlPTXflags;
        uint16 xmlPTXAtlasX;
        uint16 xmlPTXAtlasY;
        uint16 xmlPTXAtlasW;
        uint16 xmlPTXAtlasH;
        uint16 xmlPTXRows;
        uint16 xmlPTXCols;
        int32 offtoPt3;
    } rl_xptxhdrpart2;
} resListXmlPTXInfo;

typedef struct ResourceStreamGroup
{
    char  hdr[4];
    int32 rsgVerMajor; //Should be same as hdr
    int32 rsgVerMinor;
    int32 tSize; //Dummy?
    int32 dataCmnSize;
    int32 dataResidentOff;
    int32 dataResidentFileSize;
    int32 dataResidentMemSize;
    int32 dataGPULocation;
    int32 dataGPUFileSize;
    int32 dataGPUMemFileSize;
    int32 dataTransientLocation;
    int32 dataTransientFileSize;
    int32 dataTransientMemFileSize;
    /*if (decDataLen[0] <= 0 || decDataLen[1] <= 0)
    {
        Printf("\nResource Group is compressed\n");
        int32 fileOff;
        int32 compressedFileDataSize;
        int32 decFileDataSize;
    }
    else
    {
        Printf("\nRawFile\n");
        int32 fSize;
        int32 null3[2];
    }*/
    FSkip(16);
    int32 fileIdxLen;
    int32 fileIdxOffset;
    int32 texDescCnt;
    int32 texDescOffset;
    int32 texDescSize;
    //FSkip(12);
    byte  fileIndex[fileIdxLen-32];
    //FSkip(-256);
    //FSkip(fileOff);
    if (dataCmnSize == 1)
    {
        isCompressedPTXFile = 1;
    }
    int32 isPTX;
    FSkip(-sizeof fileIndex);
    FSkip(-96); //go back to RSGP to jump
    FSkip(dataResidentOff);
    if (isPTX == 1)
    {
        struct PopTextureFile
        {
            //int32 ?
            if (isCompressedPTXFile)
            {
                byte zlibCompressedPTXFiles[dataTransientLocation];
            }
            else
            {
                byte PTXFiles[dataTransientFileSize];
            }
        } PopTexture;
    }
    else
    {
        struct ResourceFile
        {
            byte ResourceFiles[dataTransientFileSize];
        } ResFile;
    }
    //else
    //{
        //byte rawFile[fSize];
    //}
    //WIP
    //struct ResourceFile
    /*
    FSkip(-24);
    int32 compressed;
    if (compressed)
    {
        int32 offst;
        int32 decompLen;
        ImageFormat ImgFmt;
        int32 dumagain[2];
        int32 texWidth;
        int32 texHeight;
    }
    FSeek(rsb1Hdr.firstResGroupDataOffst);
    byte pad[dOff];
    if (compressed)
    {
        byte zlibCompressed[cFSize];
    }
    else*/
    //{
        //byte rawFile[fSize];
    //}
} ResourceStreamsGroup;

struct ResourceStreamBin
{
    struct ResBinHeader
    {
        char header[4]<bgcolor = cBlue>;
    
        if (header == "rsb1")
        {
            BigEndian();
            Printf("PS3/X360 Resource Stream Binary\n");
        }
        if (header == "1bsr")
        {
            LittleEndian();
            Printf("Android/iOS/PS4 Resource Stream Binary\n");
        }
        int32 version<bgcolor = cYellow>; //4 = PVZ2+/Zuma's Revenge (X360), 3 = Console Ports/BejClassic/Peggle2
        if (version == 4)
        {
            local int ver4Rsb<hidden=true>  = 1;
            Printf("Version 4");
        }
        else
        {
            Printf("Version 3");
        }
        int32 verMinor;
        int32 cmnDataSize<bgcolor = cPurple>; //Dummy?
        int32 fileIdxSize<bgcolor = cWhite>;
        int32 fileIdxOffset<bgcolor = cWhite>; //70 or 108 for V3
        FSkip(8);
        int32 resGroupNameToIDSize<bgcolor = cYellow>;
        int32 resGroupNameToIDOffset<bgcolor = cYellow>;
        int32 resGroupFileCnt<bgcolor = cAqua>;
        int32 resGroupFileNameTableUTF8Offset<bgcolor = cGreen>;
        int32 resGroupFileNameTableItemSize<bgcolor = cGreen>;
        int32 resGroupInfoTableEntryCnt<bgcolor = cPurple>;
        int32 resGroupInfoTableOffset<bgcolor = cPurple>;
        int32 resGroupInfoTableItemSize<bgcolor = cPurple>;
        int32 resGroupListSize<bgcolor = cBlack>;
        int32 resGroupListOffset<bgcolor = cBlack>;
        int32 AutoPoolTableResGroupEntryCnt<bgcolor = cRed>; //Should be identical to resGroupFileCnt
        int32 AutoPoolTableOffset<bgcolor = cRed>;
        int32 AutoPoolTableItemSize<bgcolor = cRed>;
        int32 ptxInfoTableEntryCnt<bgcolor = cLtRed>;
        int32 ptxInfoTableOffset<bgcolor = cLtRed>;
        int32 ptxInfoTableItemSize<bgcolor = cLtRed>;
        int32 xmlPart1Off;
        int32 xmlPart2Off;
        int32 xmlPart3Off;
        if (ver4Rsb)
        {
            int32 resourceBinLen; //?
        }
    } rsb1Hdr;
    //struct StringTable
    //{
        //wchar_t str[9];
    //} rsbStrings;
    //int32 
    byte StringTable[rsb1Hdr.fileIdxSize]<bgcolor = cLtBlue>;
    byte SubGroupList[rsb1Hdr.resGroupNameToIDSize]<bgcolor = cYellow>;
    struct SubGroupInfoTable
    {
        for (i = 0; i < rsb1Hdr.resGroupInfoTableEntryCnt; i++)
        {
            subGroupInfo SubGroupInfoBlock<bgcolor = cGreen>;
        }
    } subg;
    byte ResGroupList[rsb1Hdr.resGroupListSize]<bgcolor = cBlack>;
    struct ResGroupInfoTable
    {
        for (i = 0; i < rsb1Hdr.resGroupFileCnt; i++)
        {
            resGroupInfo ResGroupInfoBlock<bgcolor = cPurple>;
        }
    } resginfotbl;
    struct AutoPoolTable
    {
        for (i = 0; i < rsb1Hdr.AutoPoolTableResGroupEntryCnt; i++)
        {
            autoPool AutoPoolBlock<bgcolor = cRed>;
        }
    } autoPoolTbl;
    struct PTXInfoTable
    {
        for (i = 0; i < rsb1Hdr.ptxInfoTableEntryCnt; i++)
        {
            ptxInfo PTXInfoBlock<bgcolor = cLtRed>;
        }
    } ptxInfoTbl;
    if (rsb1Hdr.xmlPart1Off != 0)
    {
        FSeek(rsb1Hdr.xmlPart1Off);
        resListXmlPTXInfo resListXML;
    }
    /*if (ver4Rsb)
    {
        if (rsb1Hdr.eighthResGroupOffst == rsb1Hdr.tenthResGroupOffst) //
        {
            FSeek(rsb1Hdr.fileStringTableUTF8Offset+1);
            string a;
        }
    }*/
    FSeek(rsb1Hdr.cmnDataSize);
    struct ResourceStreamGroups
    {
        for (i = 0; i < rsb1Hdr.resGroupFileCnt; i++)
        {
            ResourceStreamsGroup ResourceStreamsGroupFile;
        }
    } rsgps;
    /*for (i = 0; i < rsb1Hdr.resGroupFileCnt; i++)
    {
        struct RSGFileOffst
        {
            string fName;
            byte dBytes[116];
            int32 fOff;
            int32 size;
            byte  dbytes2[68];
        } rsgfOff[rsb1Hdr.resGroupFileCnt];
    }*/
    //FSeek(rsb1Hdr.firstResGroupOffst);
    //byte thirdResGroup[rsb1Hdr.thirdResGroupSize];
    //byte firstResGroup[rsb1Hdr.firstResGroupSize];
    //byte secondResGroup[rsb1Hdr.secondResGroupSize];
    //byte fourthResGroup[rsb1Hdr.fourthResGroupSize];
    //FSkip(50);
    //FSeek(rsb1Hdr.firstResGroupDataOffst);
    /*for (int i = 0; i > rsb1Hdr.resGroupFileCnt; i++)
    {
        rsg resourceGroupFile;
    }*/
    //rsg resGroup1;
    //FSeek(rsb1Hdr.secondResGroupfileIdxOffst);
    //byte secondResGroup[rsb1Hdr.secondResGroupSize];
    //FSeek(rsb1Hdr.thirdResGroupfileIdxOffst);
} popCapResourceStreamBinary;